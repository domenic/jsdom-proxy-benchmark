"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
/*!
 *  Copyright 2015 Ron Buckton (rbuckton@chronicles.org)
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
var core_1 = require("./core");
var diagnostics_1 = require("./diagnostics");
var tokens_1 = require("./tokens");
var metadata_1 = require("./metadata");
// override TypeScript __metadata decorator.
var __metadata = metadata_1.metadata;
var nextNodeId = 0;
var NodeEdge;
(function (NodeEdge) {
    function create(name, read) {
        return { name: name, isArray: false, read: read };
    }
    NodeEdge.create = create;
    function createArray(name, readArray) {
        return { name: name, isArray: true, readArray: readArray };
    }
    NodeEdge.createArray = createArray;
})(NodeEdge = exports.NodeEdge || (exports.NodeEdge = {}));
var Node = (function () {
    function Node(kind) {
        this.id = ++nextNodeId;
        this.kind = kind;
    }
    Node.prototype.getEdges = function () {
        return this._edges ? this._edges.slice() : [];
    };
    return Node;
}());
exports.Node = Node;
var StringLiteral = (function (_super) {
    __extends(StringLiteral, _super);
    function StringLiteral(text) {
        var _this = _super.call(this, tokens_1.SyntaxKind.StringLiteral) || this;
        _this.text = text;
        return _this;
    }
    return StringLiteral;
}(Node));
exports.StringLiteral = StringLiteral;
var Identifier = (function (_super) {
    __extends(Identifier, _super);
    function Identifier(text) {
        var _this = _super.call(this, tokens_1.SyntaxKind.Identifier) || this;
        _this.text = text;
        return _this;
    }
    return Identifier;
}(Node));
exports.Identifier = Identifier;
var LexicalSymbol = (function (_super) {
    __extends(LexicalSymbol, _super);
    function LexicalSymbol() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return LexicalSymbol;
}(Node));
exports.LexicalSymbol = LexicalSymbol;
var PrimarySymbol = (function (_super) {
    __extends(PrimarySymbol, _super);
    function PrimarySymbol() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return PrimarySymbol;
}(LexicalSymbol));
exports.PrimarySymbol = PrimarySymbol;
var OptionalSymbol = (function (_super) {
    __extends(OptionalSymbol, _super);
    function OptionalSymbol(kind, questionToken) {
        var _this = _super.call(this, kind) || this;
        _this.questionToken = questionToken;
        return _this;
    }
    OptionalSymbol.prototype.getChildrenCount = function () {
        return this.questionToken ? 1 : 0;
    };
    OptionalSymbol.prototype.getNthChild = function (offset) {
        return this.questionToken;
    };
    return OptionalSymbol;
}(PrimarySymbol));
__decorate([
    edge,
    __metadata("design:type", Node)
], OptionalSymbol.prototype, "questionToken", void 0);
exports.OptionalSymbol = OptionalSymbol;
var UnicodeCharacterLiteral = (function (_super) {
    __extends(UnicodeCharacterLiteral, _super);
    function UnicodeCharacterLiteral(text, questionToken) {
        var _this = _super.call(this, tokens_1.SyntaxKind.UnicodeCharacterLiteral, questionToken) || this;
        _this.text = text;
        return _this;
    }
    return UnicodeCharacterLiteral;
}(OptionalSymbol));
exports.UnicodeCharacterLiteral = UnicodeCharacterLiteral;
var UnicodeCharacterRange = (function (_super) {
    __extends(UnicodeCharacterRange, _super);
    function UnicodeCharacterRange(left, throughKeyword, right) {
        var _this = _super.call(this, tokens_1.SyntaxKind.UnicodeCharacterRange) || this;
        _this.left = left;
        _this.throughKeyword = throughKeyword;
        _this.right = right;
        return _this;
    }
    return UnicodeCharacterRange;
}(LexicalSymbol));
__decorate([
    edge,
    __metadata("design:type", UnicodeCharacterLiteral)
], UnicodeCharacterRange.prototype, "left", void 0);
__decorate([
    edge,
    __metadata("design:type", Node)
], UnicodeCharacterRange.prototype, "throughKeyword", void 0);
__decorate([
    edge,
    __metadata("design:type", UnicodeCharacterLiteral)
], UnicodeCharacterRange.prototype, "right", void 0);
exports.UnicodeCharacterRange = UnicodeCharacterRange;
var ButNotSymbol = (function (_super) {
    __extends(ButNotSymbol, _super);
    function ButNotSymbol(left, butKeyword, notKeyword, right) {
        var _this = _super.call(this, tokens_1.SyntaxKind.ButNotSymbol) || this;
        _this.left = left;
        _this.butKeyword = butKeyword;
        _this.notKeyword = notKeyword;
        _this.right = right;
        return _this;
    }
    return ButNotSymbol;
}(LexicalSymbol));
__decorate([
    edge,
    __metadata("design:type", LexicalSymbol)
], ButNotSymbol.prototype, "left", void 0);
__decorate([
    edge,
    __metadata("design:type", Node)
], ButNotSymbol.prototype, "butKeyword", void 0);
__decorate([
    edge,
    __metadata("design:type", Node)
], ButNotSymbol.prototype, "notKeyword", void 0);
__decorate([
    edge,
    __metadata("design:type", LexicalSymbol)
], ButNotSymbol.prototype, "right", void 0);
exports.ButNotSymbol = ButNotSymbol;
var Terminal = (function (_super) {
    __extends(Terminal, _super);
    function Terminal(text, questionToken) {
        var _this = _super.call(this, tokens_1.SyntaxKind.Terminal, questionToken) || this;
        _this.text = text;
        return _this;
    }
    return Terminal;
}(OptionalSymbol));
exports.Terminal = Terminal;
var TerminalList = (function (_super) {
    __extends(TerminalList, _super);
    function TerminalList(terminals) {
        if (terminals === void 0) { terminals = []; }
        var _this = _super.call(this, tokens_1.SyntaxKind.TerminalList) || this;
        _this.terminals = terminals;
        return _this;
    }
    return TerminalList;
}(Node));
__decorate([
    edge,
    __metadata("design:type", Array)
], TerminalList.prototype, "terminals", void 0);
exports.TerminalList = TerminalList;
var SymbolSet = (function (_super) {
    __extends(SymbolSet, _super);
    function SymbolSet(openBraceToken, elements, closeBraceToken) {
        var _this = _super.call(this, tokens_1.SyntaxKind.SymbolSet) || this;
        _this.openBraceToken = openBraceToken;
        _this.elements = elements;
        _this.closeBraceToken = closeBraceToken;
        return _this;
    }
    return SymbolSet;
}(Node));
__decorate([
    edge,
    __metadata("design:type", Node)
], SymbolSet.prototype, "openBraceToken", void 0);
__decorate([
    edge,
    __metadata("design:type", Array)
], SymbolSet.prototype, "elements", void 0);
__decorate([
    edge,
    __metadata("design:type", Node)
], SymbolSet.prototype, "closeBraceToken", void 0);
exports.SymbolSet = SymbolSet;
var Assertion = (function (_super) {
    __extends(Assertion, _super);
    function Assertion(kind, openBracketToken, closeBracketToken) {
        var _this = _super.call(this, kind) || this;
        _this.openBracketToken = openBracketToken;
        _this.closeBracketToken = closeBracketToken;
        return _this;
    }
    return Assertion;
}(LexicalSymbol));
__decorate([
    edge,
    __metadata("design:type", Node)
], Assertion.prototype, "openBracketToken", void 0);
__decorate([
    edge,
    __metadata("design:type", Node)
], Assertion.prototype, "closeBracketToken", void 0);
exports.Assertion = Assertion;
var EmptyAssertion = (function (_super) {
    __extends(EmptyAssertion, _super);
    function EmptyAssertion(openBracketToken, emptyKeyword, closeBracketToken) {
        var _this = _super.call(this, tokens_1.SyntaxKind.EmptyAssertion, openBracketToken, closeBracketToken) || this;
        _this.emptyKeyword = emptyKeyword;
        return _this;
    }
    return EmptyAssertion;
}(Assertion));
__decorate([
    edge,
    __metadata("design:type", Node)
], EmptyAssertion.prototype, "openBracketToken", void 0);
__decorate([
    edge,
    __metadata("design:type", Node)
], EmptyAssertion.prototype, "emptyKeyword", void 0);
__decorate([
    edge,
    __metadata("design:type", Node)
], EmptyAssertion.prototype, "closeBracketToken", void 0);
exports.EmptyAssertion = EmptyAssertion;
var LookaheadAssertion = (function (_super) {
    __extends(LookaheadAssertion, _super);
    function LookaheadAssertion(openBracketToken, lookaheadKeyword, operatorToken, lookahead, closeBracketToken) {
        var _this = _super.call(this, tokens_1.SyntaxKind.LookaheadAssertion, openBracketToken, closeBracketToken) || this;
        _this.lookaheadKeyword = lookaheadKeyword;
        _this.operatorToken = operatorToken;
        _this.lookahead = lookahead;
        return _this;
    }
    return LookaheadAssertion;
}(Assertion));
__decorate([
    edge,
    __metadata("design:type", Node)
], LookaheadAssertion.prototype, "openBracketToken", void 0);
__decorate([
    edge,
    __metadata("design:type", Node)
], LookaheadAssertion.prototype, "lookaheadKeyword", void 0);
__decorate([
    edge,
    __metadata("design:type", Node)
], LookaheadAssertion.prototype, "operatorToken", void 0);
__decorate([
    edge,
    __metadata("design:type", Object)
], LookaheadAssertion.prototype, "lookahead", void 0);
__decorate([
    edge,
    __metadata("design:type", Node)
], LookaheadAssertion.prototype, "closeBracketToken", void 0);
exports.LookaheadAssertion = LookaheadAssertion;
var LexicalGoalAssertion = (function (_super) {
    __extends(LexicalGoalAssertion, _super);
    function LexicalGoalAssertion(openBracketToken, lexicalKeyword, goalKeyword, symbol, closeBracketToken) {
        var _this = _super.call(this, tokens_1.SyntaxKind.LexicalGoalAssertion, openBracketToken, closeBracketToken) || this;
        _this.lexicalKeyword = lexicalKeyword;
        _this.goalKeyword = goalKeyword;
        _this.symbol = symbol;
        return _this;
    }
    return LexicalGoalAssertion;
}(Assertion));
__decorate([
    edge,
    __metadata("design:type", Node)
], LexicalGoalAssertion.prototype, "openBracketToken", void 0);
__decorate([
    edge,
    __metadata("design:type", Node)
], LexicalGoalAssertion.prototype, "lexicalKeyword", void 0);
__decorate([
    edge,
    __metadata("design:type", Node)
], LexicalGoalAssertion.prototype, "goalKeyword", void 0);
__decorate([
    edge,
    __metadata("design:type", Identifier)
], LexicalGoalAssertion.prototype, "symbol", void 0);
__decorate([
    edge,
    __metadata("design:type", Node)
], LexicalGoalAssertion.prototype, "closeBracketToken", void 0);
exports.LexicalGoalAssertion = LexicalGoalAssertion;
var NoSymbolHereAssertion = (function (_super) {
    __extends(NoSymbolHereAssertion, _super);
    function NoSymbolHereAssertion(openBracketToken, noKeyword, symbols, hereKeyword, closeBracketToken) {
        var _this = _super.call(this, tokens_1.SyntaxKind.NoSymbolHereAssertion, openBracketToken, closeBracketToken) || this;
        _this.noKeyword = noKeyword;
        _this.symbols = symbols;
        _this.hereKeyword = hereKeyword;
        return _this;
    }
    return NoSymbolHereAssertion;
}(Assertion));
__decorate([
    edge,
    __metadata("design:type", Node)
], NoSymbolHereAssertion.prototype, "openBracketToken", void 0);
__decorate([
    edge,
    __metadata("design:type", Node)
], NoSymbolHereAssertion.prototype, "noKeyword", void 0);
__decorate([
    edge,
    __metadata("design:type", Array)
], NoSymbolHereAssertion.prototype, "symbols", void 0);
__decorate([
    edge,
    __metadata("design:type", Node)
], NoSymbolHereAssertion.prototype, "hereKeyword", void 0);
__decorate([
    edge,
    __metadata("design:type", Node)
], NoSymbolHereAssertion.prototype, "closeBracketToken", void 0);
exports.NoSymbolHereAssertion = NoSymbolHereAssertion;
var ParameterValueAssertion = (function (_super) {
    __extends(ParameterValueAssertion, _super);
    function ParameterValueAssertion(openBracketToken, operatorToken, name, closeBracketToken) {
        var _this = _super.call(this, tokens_1.SyntaxKind.ParameterValueAssertion, openBracketToken, closeBracketToken) || this;
        _this.operatorToken = operatorToken;
        _this.name = name;
        return _this;
    }
    return ParameterValueAssertion;
}(Assertion));
__decorate([
    edge,
    __metadata("design:type", Node)
], ParameterValueAssertion.prototype, "openBracketToken", void 0);
__decorate([
    edge,
    __metadata("design:type", Node)
], ParameterValueAssertion.prototype, "operatorToken", void 0);
__decorate([
    edge,
    __metadata("design:type", Identifier)
], ParameterValueAssertion.prototype, "name", void 0);
__decorate([
    edge,
    __metadata("design:type", Node)
], ParameterValueAssertion.prototype, "closeBracketToken", void 0);
exports.ParameterValueAssertion = ParameterValueAssertion;
var ProseAssertion = (function (_super) {
    __extends(ProseAssertion, _super);
    function ProseAssertion(openBracketToken, fragments, closeBracketToken) {
        var _this = _super.call(this, tokens_1.SyntaxKind.ProseAssertion, openBracketToken, closeBracketToken) || this;
        _this.fragments = fragments;
        return _this;
    }
    return ProseAssertion;
}(Assertion));
__decorate([
    edge,
    __metadata("design:type", Node)
], ProseAssertion.prototype, "openBracketToken", void 0);
__decorate([
    edge,
    __metadata("design:type", Array)
], ProseAssertion.prototype, "fragments", void 0);
__decorate([
    edge,
    __metadata("design:type", Node)
], ProseAssertion.prototype, "closeBracketToken", void 0);
exports.ProseAssertion = ProseAssertion;
var ProseFragmentLiteral = (function (_super) {
    __extends(ProseFragmentLiteral, _super);
    function ProseFragmentLiteral(kind, text) {
        var _this = _super.call(this, kind) || this;
        _this.text = text;
        return _this;
    }
    return ProseFragmentLiteral;
}(Node));
exports.ProseFragmentLiteral = ProseFragmentLiteral;
var Argument = (function (_super) {
    __extends(Argument, _super);
    function Argument(operatorToken, name) {
        var _this = _super.call(this, tokens_1.SyntaxKind.Argument) || this;
        _this.operatorToken = operatorToken;
        _this.name = name;
        return _this;
    }
    return Argument;
}(Node));
__decorate([
    edge,
    __metadata("design:type", Node)
], Argument.prototype, "operatorToken", void 0);
__decorate([
    edge,
    __metadata("design:type", Identifier)
], Argument.prototype, "name", void 0);
exports.Argument = Argument;
var ArgumentList = (function (_super) {
    __extends(ArgumentList, _super);
    function ArgumentList(openParenToken, elements, closeParenToken) {
        var _this = _super.call(this, tokens_1.SyntaxKind.ArgumentList) || this;
        _this.openParenToken = openParenToken;
        _this.elements = elements;
        _this.closeParenToken = closeParenToken;
        return _this;
    }
    return ArgumentList;
}(Node));
__decorate([
    edge,
    __metadata("design:type", Node)
], ArgumentList.prototype, "openParenToken", void 0);
__decorate([
    edge,
    __metadata("design:type", Array)
], ArgumentList.prototype, "elements", void 0);
__decorate([
    edge,
    __metadata("design:type", Node)
], ArgumentList.prototype, "closeParenToken", void 0);
exports.ArgumentList = ArgumentList;
var Nonterminal = (function (_super) {
    __extends(Nonterminal, _super);
    function Nonterminal(name, argumentList, questionToken) {
        var _this = _super.call(this, tokens_1.SyntaxKind.Nonterminal, questionToken) || this;
        _this.name = name;
        _this.argumentList = argumentList;
        return _this;
    }
    return Nonterminal;
}(OptionalSymbol));
__decorate([
    edge,
    __metadata("design:type", Identifier)
], Nonterminal.prototype, "name", void 0);
__decorate([
    edge,
    __metadata("design:type", ArgumentList)
], Nonterminal.prototype, "argumentList", void 0);
exports.Nonterminal = Nonterminal;
var Prose = (function (_super) {
    __extends(Prose, _super);
    function Prose(greaterThanToken, fragments) {
        var _this = _super.call(this, tokens_1.SyntaxKind.Prose) || this;
        _this.greaterThanToken = greaterThanToken;
        _this.fragments = fragments;
        return _this;
    }
    return Prose;
}(LexicalSymbol));
__decorate([
    edge,
    __metadata("design:type", Node)
], Prose.prototype, "greaterThanToken", void 0);
__decorate([
    edge,
    __metadata("design:type", Array)
], Prose.prototype, "fragments", void 0);
exports.Prose = Prose;
var OneOfSymbol = (function (_super) {
    __extends(OneOfSymbol, _super);
    function OneOfSymbol(oneKeyword, ofKeyword, symbols) {
        var _this = _super.call(this, tokens_1.SyntaxKind.OneOfSymbol) || this;
        _this.oneKeyword = oneKeyword;
        _this.ofKeyword = ofKeyword;
        _this.symbols = symbols;
        return _this;
    }
    return OneOfSymbol;
}(LexicalSymbol));
__decorate([
    edge,
    __metadata("design:type", Node)
], OneOfSymbol.prototype, "oneKeyword", void 0);
__decorate([
    edge,
    __metadata("design:type", Node)
], OneOfSymbol.prototype, "ofKeyword", void 0);
__decorate([
    edge,
    __metadata("design:type", Array)
], OneOfSymbol.prototype, "symbols", void 0);
exports.OneOfSymbol = OneOfSymbol;
var SymbolSpan = (function (_super) {
    __extends(SymbolSpan, _super);
    function SymbolSpan(symbol, next) {
        var _this = _super.call(this, tokens_1.SyntaxKind.SymbolSpan) || this;
        _this.symbol = symbol;
        _this.next = next;
        return _this;
    }
    return SymbolSpan;
}(Node));
__decorate([
    edge,
    __metadata("design:type", LexicalSymbol)
], SymbolSpan.prototype, "symbol", void 0);
__decorate([
    edge,
    __metadata("design:type", SymbolSpan)
], SymbolSpan.prototype, "next", void 0);
exports.SymbolSpan = SymbolSpan;
var LinkReference = (function (_super) {
    __extends(LinkReference, _super);
    function LinkReference(text) {
        var _this = _super.call(this, tokens_1.SyntaxKind.LinkReference) || this;
        _this.text = text;
        return _this;
    }
    return LinkReference;
}(Node));
exports.LinkReference = LinkReference;
var RightHandSide = (function (_super) {
    __extends(RightHandSide, _super);
    function RightHandSide(head, reference) {
        var _this = _super.call(this, tokens_1.SyntaxKind.RightHandSide) || this;
        _this.head = head;
        _this.reference = reference;
        return _this;
    }
    return RightHandSide;
}(Node));
__decorate([
    edge,
    __metadata("design:type", SymbolSpan)
], RightHandSide.prototype, "head", void 0);
__decorate([
    edge,
    __metadata("design:type", LinkReference)
], RightHandSide.prototype, "reference", void 0);
exports.RightHandSide = RightHandSide;
var RightHandSideList = (function (_super) {
    __extends(RightHandSideList, _super);
    function RightHandSideList(openIndentToken, elements, closeIndentToken) {
        var _this = _super.call(this, tokens_1.SyntaxKind.RightHandSideList) || this;
        _this.openIndentToken = openIndentToken;
        _this.elements = elements;
        _this.closeIndentToken = closeIndentToken;
        return _this;
    }
    return RightHandSideList;
}(Node));
__decorate([
    edge,
    __metadata("design:type", Node)
], RightHandSideList.prototype, "openIndentToken", void 0);
__decorate([
    edge,
    __metadata("design:type", Array)
], RightHandSideList.prototype, "elements", void 0);
__decorate([
    edge,
    __metadata("design:type", Node)
], RightHandSideList.prototype, "closeIndentToken", void 0);
exports.RightHandSideList = RightHandSideList;
var OneOfList = (function (_super) {
    __extends(OneOfList, _super);
    function OneOfList(oneKeyword, ofKeyword, openIndentToken, terminals, closeIndentToken) {
        var _this = _super.call(this, tokens_1.SyntaxKind.OneOfList) || this;
        _this.oneKeyword = oneKeyword;
        _this.ofKeyword = ofKeyword;
        _this.openIndentToken = openIndentToken;
        _this.terminals = terminals;
        _this.closeIndentToken = closeIndentToken;
        return _this;
    }
    return OneOfList;
}(Node));
__decorate([
    edge,
    __metadata("design:type", Node)
], OneOfList.prototype, "openIndentToken", void 0);
__decorate([
    edge,
    __metadata("design:type", Node)
], OneOfList.prototype, "oneKeyword", void 0);
__decorate([
    edge,
    __metadata("design:type", Node)
], OneOfList.prototype, "ofKeyword", void 0);
__decorate([
    edge,
    __metadata("design:type", Array)
], OneOfList.prototype, "terminals", void 0);
__decorate([
    edge,
    __metadata("design:type", Node)
], OneOfList.prototype, "closeIndentToken", void 0);
exports.OneOfList = OneOfList;
var Parameter = (function (_super) {
    __extends(Parameter, _super);
    function Parameter(name) {
        var _this = _super.call(this, tokens_1.SyntaxKind.Parameter) || this;
        _this.name = name;
        return _this;
    }
    return Parameter;
}(Node));
__decorate([
    edge,
    __metadata("design:type", Identifier)
], Parameter.prototype, "name", void 0);
exports.Parameter = Parameter;
var ParameterList = (function (_super) {
    __extends(ParameterList, _super);
    function ParameterList(openParenToken, elements, closeParenToken) {
        var _this = _super.call(this, tokens_1.SyntaxKind.ParameterList) || this;
        _this.openParenToken = openParenToken;
        _this.elements = elements;
        _this.closeParenToken = closeParenToken;
        return _this;
    }
    return ParameterList;
}(Node));
__decorate([
    edge,
    __metadata("design:type", Node)
], ParameterList.prototype, "openParenToken", void 0);
__decorate([
    edge,
    __metadata("design:type", Array)
], ParameterList.prototype, "elements", void 0);
__decorate([
    edge,
    __metadata("design:type", Node)
], ParameterList.prototype, "closeParenToken", void 0);
exports.ParameterList = ParameterList;
var SourceElement = (function (_super) {
    __extends(SourceElement, _super);
    function SourceElement() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return SourceElement;
}(Node));
exports.SourceElement = SourceElement;
var Production = (function (_super) {
    __extends(Production, _super);
    function Production(name, parameters, colonToken, body) {
        var _this = _super.call(this, tokens_1.SyntaxKind.Production) || this;
        _this.name = name;
        _this.parameterList = parameters;
        _this.colonToken = colonToken;
        _this.body = body;
        return _this;
    }
    return Production;
}(SourceElement));
__decorate([
    edge,
    __metadata("design:type", Identifier)
], Production.prototype, "name", void 0);
__decorate([
    edge,
    __metadata("design:type", Node)
], Production.prototype, "colonToken", void 0);
__decorate([
    edge,
    __metadata("design:type", ParameterList)
], Production.prototype, "parameterList", void 0);
__decorate([
    edge,
    __metadata("design:type", Object)
], Production.prototype, "body", void 0);
exports.Production = Production;
var MetaElement = (function (_super) {
    __extends(MetaElement, _super);
    function MetaElement(kind, atToken) {
        var _this = _super.call(this, kind) || this;
        _this.atToken = atToken;
        return _this;
    }
    return MetaElement;
}(SourceElement));
__decorate([
    edge,
    __metadata("design:type", Node)
], MetaElement.prototype, "atToken", void 0);
exports.MetaElement = MetaElement;
var Import = (function (_super) {
    __extends(Import, _super);
    function Import(atToken, importKeyword, path) {
        var _this = _super.call(this, tokens_1.SyntaxKind.Import, atToken) || this;
        _this.importKeyword = importKeyword;
        _this.path = path;
        return _this;
    }
    return Import;
}(MetaElement));
__decorate([
    edge,
    __metadata("design:type", Node)
], Import.prototype, "importKeyword", void 0);
__decorate([
    edge,
    __metadata("design:type", StringLiteral)
], Import.prototype, "path", void 0);
exports.Import = Import;
var Define = (function (_super) {
    __extends(Define, _super);
    function Define(atToken, defineKeyword, key, valueToken) {
        var _this = _super.call(this, tokens_1.SyntaxKind.Define, atToken) || this;
        _this.defineKeyword = defineKeyword;
        _this.key = key;
        _this.valueToken = valueToken;
        return _this;
    }
    return Define;
}(MetaElement));
__decorate([
    edge,
    __metadata("design:type", Node)
], Define.prototype, "defineKeyword", void 0);
__decorate([
    edge,
    __metadata("design:type", Identifier)
], Define.prototype, "key", void 0);
__decorate([
    edge,
    __metadata("design:type", Node)
], Define.prototype, "valueToken", void 0);
exports.Define = Define;
var SourceFile = (function (_super) {
    __extends(SourceFile, _super);
    function SourceFile(filename, text) {
        var _this = _super.call(this, tokens_1.SyntaxKind.SourceFile) || this;
        _this.filename = filename;
        _this.text = text;
        _this.lineMap = new diagnostics_1.LineMap(text);
        _this.pos = 0;
        _this.end = _this.text.length;
        return _this;
    }
    return SourceFile;
}(Node));
__decorate([
    edge,
    __metadata("design:type", Array)
], SourceFile.prototype, "elements", void 0);
exports.SourceFile = SourceFile;
function visitNode(node, cbNode) {
    if (node) {
        return cbNode(node);
    }
    return undefined;
}
function visitNodes(nodes, cbNode) {
    if (nodes) {
        var result = void 0;
        for (var i = 0; i < nodes.length; i++) {
            result = visitNode(nodes[i], cbNode);
            if (result) {
                return result;
            }
        }
    }
    return undefined;
}
function forEachChild(node, cbNode) {
    if (node) {
        switch (node.kind) {
            case tokens_1.SyntaxKind.TerminalList:
                return visitNodes(node.terminals, cbNode);
            case tokens_1.SyntaxKind.SymbolSet:
                return visitNode(node.openBraceToken, cbNode)
                    || visitNodes(node.elements, cbNode)
                    || visitNode(node.closeBraceToken, cbNode);
            case tokens_1.SyntaxKind.EmptyAssertion:
                return visitNode(node.openBracketToken, cbNode)
                    || visitNode(node.emptyKeyword, cbNode)
                    || visitNode(node.closeBracketToken, cbNode);
            case tokens_1.SyntaxKind.LookaheadAssertion:
                return visitNode(node.openBracketToken, cbNode)
                    || visitNode(node.lookaheadKeyword, cbNode)
                    || visitNode(node.operatorToken, cbNode)
                    || visitNode(node.lookahead, cbNode)
                    || visitNode(node.closeBracketToken, cbNode);
            case tokens_1.SyntaxKind.LexicalGoalAssertion:
                return visitNode(node.openBracketToken, cbNode)
                    || visitNode(node.lexicalKeyword, cbNode)
                    || visitNode(node.goalKeyword, cbNode)
                    || visitNode(node.symbol, cbNode)
                    || visitNode(node.closeBracketToken, cbNode);
            case tokens_1.SyntaxKind.NoSymbolHereAssertion:
                return visitNode(node.openBracketToken, cbNode)
                    || visitNode(node.noKeyword, cbNode)
                    || visitNodes(node.symbols, cbNode)
                    || visitNode(node.hereKeyword, cbNode)
                    || visitNode(node.closeBracketToken, cbNode);
            case tokens_1.SyntaxKind.ParameterValueAssertion:
                return visitNode(node.openBracketToken, cbNode)
                    || visitNode(node.operatorToken, cbNode)
                    || visitNode(node.name, cbNode)
                    || visitNode(node.closeBracketToken, cbNode);
            case tokens_1.SyntaxKind.ProseAssertion:
                return visitNode(node.openBracketToken, cbNode)
                    || visitNodes(node.fragments, cbNode)
                    || visitNode(node.closeBracketToken, cbNode);
            case tokens_1.SyntaxKind.InvalidAssertion:
                return visitNode(node.openBracketToken, cbNode)
                    || visitNode(node.closeBracketToken, cbNode);
            case tokens_1.SyntaxKind.Prose:
                return visitNode(node.greaterThanToken, cbNode)
                    || visitNodes(node.fragments, cbNode);
            case tokens_1.SyntaxKind.Terminal:
            case tokens_1.SyntaxKind.UnicodeCharacterLiteral:
                return visitNode(node.questionToken, cbNode);
            case tokens_1.SyntaxKind.Nonterminal:
                return visitNode(node.name, cbNode)
                    || visitNode(node.argumentList, cbNode)
                    || visitNode(node.questionToken, cbNode);
            case tokens_1.SyntaxKind.OneOfSymbol:
                return visitNodes(node.symbols, cbNode);
            case tokens_1.SyntaxKind.ButNotSymbol:
                return visitNode(node.left, cbNode)
                    || visitNode(node.butKeyword, cbNode)
                    || visitNode(node.notKeyword, cbNode)
                    || visitNode(node.right, cbNode);
            case tokens_1.SyntaxKind.UnicodeCharacterRange:
                return visitNode(node.left, cbNode)
                    || visitNode(node.throughKeyword, cbNode)
                    || visitNode(node.right, cbNode);
            case tokens_1.SyntaxKind.SymbolSpan:
                return visitNode(node.symbol, cbNode)
                    || visitNode(node.next, cbNode);
            case tokens_1.SyntaxKind.RightHandSide:
                return visitNode(node.head, cbNode)
                    || visitNode(node.reference, cbNode);
            case tokens_1.SyntaxKind.RightHandSideList:
                return visitNode(node.openIndentToken, cbNode)
                    || visitNodes(node.elements, cbNode)
                    || visitNode(node.closeIndentToken, cbNode);
            case tokens_1.SyntaxKind.OneOfList:
                return visitNode(node.oneKeyword, cbNode)
                    || visitNode(node.ofKeyword, cbNode)
                    || visitNode(node.openIndentToken, cbNode)
                    || visitNodes(node.terminals, cbNode)
                    || visitNode(node.closeIndentToken, cbNode);
            case tokens_1.SyntaxKind.Parameter:
                return visitNode(node.name, cbNode);
            case tokens_1.SyntaxKind.ParameterList:
                return visitNode(node.openParenToken, cbNode)
                    || visitNodes(node.elements, cbNode)
                    || visitNode(node.closeParenToken, cbNode);
            case tokens_1.SyntaxKind.Argument:
                return visitNode(node.operatorToken, cbNode)
                    || visitNode(node.name, cbNode);
            case tokens_1.SyntaxKind.ArgumentList:
                return visitNode(node.openParenToken, cbNode)
                    || visitNodes(node.elements, cbNode)
                    || visitNode(node.closeParenToken, cbNode);
            case tokens_1.SyntaxKind.Production:
                return visitNode(node.name, cbNode)
                    || visitNode(node.parameterList, cbNode)
                    || visitNode(node.body, cbNode);
            case tokens_1.SyntaxKind.Import:
                return visitNode(node.atToken, cbNode)
                    || visitNode(node.importKeyword, cbNode)
                    || visitNode(node.path, cbNode);
            case tokens_1.SyntaxKind.SourceFile:
                return visitNodes(node.elements, cbNode);
        }
    }
    return undefined;
}
exports.forEachChild = forEachChild;
function ensureEdges(target) {
    if (!Object.prototype.hasOwnProperty.call(target, "_edges")) {
        Object.defineProperty(target, "_edges", { value: [] });
    }
    return target._edges;
}
function addEdge(target, edge) {
    ensureEdges(target).push(edge);
}
function edge(target, name) {
    var designType = metadata_1.getPropertyMetadata(target, name, "design:type");
    var read = function (node) { return core_1.Dictionary.get(node, name); };
    var edge = designType === Array
        ? NodeEdge.createArray(name, read)
        : NodeEdge.create(name, read);
    addEdge(target, edge);
}
exports.edge = edge;
//# sourceMappingURL=nodes.js.map
