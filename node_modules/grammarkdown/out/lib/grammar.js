"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var fs = require("fs");
var performance = require("./performance");
var core_1 = require("./core");
var host_1 = require("./host");
var diagnostics_1 = require("./diagnostics");
var options_1 = require("./options");
var tokens_1 = require("./tokens");
var parser_1 = require("./parser");
var binder_1 = require("./binder");
var checker_1 = require("./checker");
var index_1 = require("./emitter/index");
var prex_1 = require("prex");
var Grammar = (function () {
    function Grammar(rootNames, options, readFileOrHostLike, oldGrammar, token) {
        if (options === void 0) { options = options_1.getDefaultOptions(); }
        if (token === void 0) { token = prex_1.CancellationToken.none; }
        this.rootFiles = [];
        this.sourceFiles = [];
        this.diagnostics = new diagnostics_1.DiagnosticMessages();
        this.bindings = new binder_1.BindingTable();
        this.fileMap = new core_1.Dictionary();
        this.host = host_1.Host.getHost(readFileOrHostLike);
        this.options = options;
        this.oldGrammar = oldGrammar;
        this.cancellationToken = token;
        this.parse(rootNames);
        this.oldGrammar = undefined;
        Object.freeze(this.sourceFiles);
    }
    Object.defineProperty(Grammar.prototype, "resolver", {
        get: function () {
            return this.checker.resolver;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Grammar.prototype, "parser", {
        get: function () {
            if (!this.innerParser) {
                this.innerParser = this.createParser(this.options);
            }
            return this.innerParser;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Grammar.prototype, "binder", {
        get: function () {
            if (!this.innerBinder) {
                this.innerBinder = this.createBinder(this.options, this.bindings);
            }
            return this.innerBinder;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Grammar.prototype, "checker", {
        get: function () {
            if (!this.innerChecker) {
                this.innerChecker = this.createChecker(this.options, this.bindings);
            }
            return this.innerChecker;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Grammar.prototype, "emitter", {
        get: function () {
            if (!this.innerEmitter) {
                this.innerEmitter = this.createEmitter(this.options, this.checker.resolver);
            }
            return this.innerEmitter;
        },
        enumerable: true,
        configurable: true
    });
    Grammar.registerKnownGrammar = function (name, file) {
        core_1.Dictionary.set(Grammar.knownGrammars, name, file);
    };
    Grammar.prototype.getSourceFile = function (file) {
        file = this.resolveFile(file);
        return core_1.Dictionary.get(this.fileMap, this.normalizeFile(file));
    };
    /** Adds a synthetic SourceFile to the grammar. */
    Grammar.prototype.addSourceFile = function (sourceFile) {
        var file = this.normalizeFile(this.resolveFile(sourceFile.filename));
        if (core_1.Dictionary.has(this.fileMap, file))
            throw new Error("A sourceFile for the file name " + file + " already exists in the collection.");
        core_1.Dictionary.set(this.fileMap, file, sourceFile);
        this.processImports(sourceFile, file);
        this.rootFiles.push(sourceFile);
    };
    Grammar.prototype.parse = function (rootNames) {
        performance.mark("beforeParse");
        for (var _i = 0, rootNames_1 = rootNames; _i < rootNames_1.length; _i++) {
            var rootName = rootNames_1[_i];
            this.processRootFile(this.resolveFile(rootName));
        }
        performance.mark("afterParse");
        performance.measure("parse", "beforeParse", "afterParse");
    };
    Grammar.prototype.bind = function (sourceFile) {
        if (sourceFile) {
            console.warn("Calling 'Grammar#bind' with a SourceFile is an obsolete overload and will be removed in a future version.");
        }
        var binder = this.binder;
        performance.mark("beforeBind");
        for (var _i = 0, _a = this.sourceFiles; _i < _a.length; _i++) {
            var sourceFile_1 = _a[_i];
            binder.bindSourceFile(sourceFile_1);
        }
        performance.mark("afterBind");
        performance.measure("bind", "beforeBind", "afterBind");
    };
    Grammar.prototype.check = function (sourceFile) {
        this.bind();
        var checker = this.checker;
        performance.mark("beforeCheck");
        if (sourceFile) {
            checker.checkSourceFile(sourceFile);
        }
        else {
            for (var _i = 0, _a = this.sourceFiles; _i < _a.length; _i++) {
                var sourceFile_2 = _a[_i];
                checker.checkSourceFile(sourceFile_2);
            }
        }
        performance.mark("afterCheck");
        performance.measure("check", "beforeCheck", "afterCheck");
    };
    Grammar.prototype.resetEmitter = function () {
        this.innerEmitter = undefined;
    };
    Grammar.prototype.emit = function (sourceFile, writeFile) {
        var _this = this;
        if (writeFile === void 0) { writeFile = function (file, content) { return _this.writeFile(file, content); }; }
        this.bind(sourceFile);
        this.check(sourceFile);
        var emitter = this.emitter;
        performance.mark("beforeEmit");
        if (sourceFile) {
            emitter.emit(sourceFile, writeFile);
        }
        else {
            for (var _i = 0, _a = this.rootFiles; _i < _a.length; _i++) {
                var sourceFile_3 = _a[_i];
                emitter.emit(sourceFile_3, writeFile);
            }
        }
        performance.mark("afterEmit");
        performance.measure("emit", "beforeEmit", "afterEmit");
    };
    Grammar.prototype.createParser = function (options) {
        return new parser_1.Parser(this.diagnostics, this.cancellationToken);
    };
    Grammar.prototype.createBinder = function (options, bindings) {
        return new binder_1.Binder(bindings, this.cancellationToken);
    };
    Grammar.prototype.createChecker = function (options, bindings) {
        return new checker_1.Checker(bindings, options.noChecks ? diagnostics_1.NullDiagnosticMessages.instance : this.diagnostics, options, this.cancellationToken);
    };
    Grammar.prototype.createEmitter = function (options, resolver) {
        switch (options.format) {
            case options_1.EmitFormat.ecmarkup:
                return new index_1.EcmarkupEmitter(options, resolver, this.diagnostics, this.cancellationToken);
            case options_1.EmitFormat.html:
                return new index_1.HtmlEmitter(options, resolver, this.diagnostics, this.cancellationToken);
            case options_1.EmitFormat.markdown:
            default:
                return new index_1.MarkdownEmitter(options, resolver, this.diagnostics, this.cancellationToken);
        }
    };
    Grammar.prototype.readFile = function (file) {
        performance.mark("ioRead");
        var content = this.host.readFile(file);
        performance.measure("ioRead", "ioRead");
        return content;
    };
    Grammar.prototype.writeFile = function (file, content) {
        performance.mark("ioWrite");
        this.host.writeFile(file, content);
        performance.measure("ioWrite", "ioWrite");
    };
    Grammar.prototype.resolveFile = function (file, referer) {
        file = core_1.Dictionary.get(Grammar.knownGrammars, file) || file;
        return this.host.resolveFile(file, referer);
    };
    Grammar.prototype.normalizeFile = function (file) {
        return this.host.normalizeFile(file);
    };
    Grammar.prototype.processRootFile = function (file) {
        var sourceFile = this.processFile(file);
        if (sourceFile === undefined) {
            throw new Error("Invalid source file");
        }
        if (this.rootFiles.indexOf(sourceFile) === -1) {
            this.rootFiles.push(sourceFile);
        }
    };
    Grammar.prototype.processFile = function (file, referer, refererPos, refererEnd) {
        var sourceFile = this.getSourceFile(file);
        if (sourceFile) {
            return sourceFile;
        }
        else {
            sourceFile = this.parseSourceFile(file);
            if (sourceFile) {
                core_1.Dictionary.set(this.fileMap, this.normalizeFile(file), sourceFile);
                this.sourceFiles.push(sourceFile);
                this.processImports(sourceFile, file);
            }
        }
        return sourceFile;
    };
    Grammar.prototype.processImports = function (sourceFile, refererName) {
        for (var _i = 0, _a = sourceFile.elements; _i < _a.length; _i++) {
            var element = _a[_i];
            if (element.kind === tokens_1.SyntaxKind.Import) {
                var importNode = element;
                if (importNode.path) {
                    var importPath = this.resolveFile(importNode.path.text, refererName);
                    this.processFile(importPath, sourceFile, importNode.pos, importNode.end);
                }
            }
        }
    };
    Grammar.prototype.parseSourceFile = function (file) {
        var sourceText = this.readFile(file);
        if (sourceText !== undefined) {
            if (this.oldGrammar) {
                var oldSourceFile = this.oldGrammar.getSourceFile(file);
                if (oldSourceFile && oldSourceFile.text === sourceText) {
                    return oldSourceFile;
                }
            }
            return this.parser.parseSourceFile(file, sourceText);
        }
        return undefined;
    };
    return Grammar;
}());
Grammar.knownGrammars = new core_1.Dictionary({
    "es6": require.resolve("../../grammars/es2015.grammar"),
    "es2015": require.resolve("../../grammars/es2015.grammar"),
    // "es2016": require.resolve("../../grammars/es2016.grammar"),
    "ts": require.resolve("../../grammars/typescript.grammar"),
    "typescript": require.resolve("../../grammars/typescript.grammar"),
});
exports.Grammar = Grammar;
function readFile(file) {
    return fs.readFileSync(file, "utf8");
}
//# sourceMappingURL=grammar.js.map
