import { Range, Position } from "./core";
import { SyntaxKind } from "./tokens";
import { Node, SourceFile } from "./nodes";
export interface Diagnostic {
    code: number;
    message: string;
    warning?: boolean;
}
export declare const Diagnostics: {
    Constant_expected: Diagnostic;
    _0_expected: Diagnostic;
    _0_or_1_: Diagnostic;
    Unexpected_token_0_: Diagnostic;
    Invalid_character: Diagnostic;
    Unterminated_string_literal: Diagnostic;
    Invalid_escape_sequence: Diagnostic;
    Digit_expected: Diagnostic;
    Production_expected: Diagnostic;
    Unterminated_identifier_literal: Diagnostic;
    Obsolete_0_: Diagnostic;
    Cannot_find_name_0_: Diagnostic;
    Duplicate_identifier_0_: Diagnostic;
    Duplicate_terminal_0_: Diagnostic;
    Argument_0_cannot_be_specified_multiple_times: Diagnostic;
    Production_0_does_not_have_a_parameter_named_1_: Diagnostic;
    Production_0_is_missing_parameter_1_All_definitions_of_production_0_must_specify_the_same_formal_parameters: Diagnostic;
    There_is_no_argument_given_for_parameter_0_: Diagnostic;
};
export interface DiagnosticInfo {
    diagnosticIndex: number;
    code: number;
    message: string;
    messageArguments: any[];
    warning: boolean;
    range: Range;
    sourceFile: SourceFile;
    node: Node;
    pos: number;
    formattedMessage?: string;
}
export declare class DiagnosticMessages {
    private diagnostics;
    private diagnosticsPos;
    private diagnosticsLength;
    private diagnosticsNode;
    private diagnosticsArguments;
    private detailedDiagnosticMessages;
    private simpleDiagnosticMessages;
    private sourceFiles;
    private sourceFilesDiagnosticOffset;
    private nextDiagnosticIndex;
    private sortedAndDeduplicatedDiagnosticIndices;
    constructor();
    setSourceFile(sourceFile: SourceFile): void;
    report(pos: number, message: Diagnostic, args: any[]): void;
    report(pos: number, message: Diagnostic, ...args: any[]): void;
    reportNode(node: Node, message: Diagnostic, args: any[]): void;
    reportNode(node: Node, message: Diagnostic, ...args: any[]): void;
    count(): number;
    getMessage(diagnosticIndex: number, options?: {
        detailed?: boolean;
    }): string;
    getDiagnostic(diagnosticIndex: number): Diagnostic;
    getDiagnosticInfos(options?: {
        formatMessage?: boolean;
        detailedMessage?: boolean;
    }): DiagnosticInfo[];
    getDiagnosticInfosForSourceFile(sourceFile: SourceFile, options?: {
        formatMessage?: boolean;
        detailedMessage?: boolean;
    }): DiagnosticInfo[];
    getDiagnosticInfo(diagnosticIndex: number, options?: {
        formatMessage?: boolean;
        detailedMessage?: boolean;
    }): DiagnosticInfo;
    getDiagnosticArguments(diagnosticIndex: number): any[];
    getDiagnosticRange(diagnosticIndex: number): Range;
    getDiagnosticNode(diagnosticIndex: number): Node;
    forEach(callback: (message: string, diagnosticIndex: number) => void): void;
    private getSortedAndDeduplicatedDiagnosticIndices();
    private sortDiagnostics(indices);
    private compareDiagnostics(diagnosticIndex1, diagnosticIndex2);
    private deduplicateDiagnostics(indices);
    private getDiagnosticPos(diagnosticIndex);
    private getDiagnosticLength(diagnosticIndex);
    private getDiagnosticCode(diagnosticIndex);
    private getDiagnosticErrorLevel(diagnosticIndex);
    private reportDiagnostic(message, args, pos?, length?, node?);
    getDiagnosticSourceFile(diagnosticIndex: number): SourceFile;
}
export declare class NullDiagnosticMessages extends DiagnosticMessages {
    private static _instance;
    static readonly instance: NullDiagnosticMessages;
    reportCore(message: Diagnostic, arg0?: any, arg1?: any): number;
    report(pos: number, message: Diagnostic, arg0?: any, arg1?: any): number;
    reportNode(node: Node, message: Diagnostic, arg0?: any, arg1?: any): number;
    count(): number;
    getMessage(diagnosticIndex: number): string;
    getDiagnostic(diagnosticIndex: number): Diagnostic;
    getDiagnosticNode(diagnosticIndex: number): Node;
    forEach(callback: (message: string, diagnosticIndex: number) => void): void;
}
export declare class LineMap {
    private text;
    private lineStarts;
    constructor(text: string);
    readonly lineCount: number;
    formatPosition(pos: number): string;
    getPositionOfLineAndCharacter(lineAndCharacter: Position): number;
    getLineAndCharacterOfPosition(pos: number): Position;
    formatOffset(pos: number): string;
    offsetAt(position: Position): number;
    positionAt(offset: number): Position;
    private computeLineStarts();
    private isLineBreak(ch);
}
export declare function formatString(format: string, args?: any[]): string;
export declare function formatString(format: string, ...args: any[]): string;
export declare function formatList(tokens: SyntaxKind[]): string;
