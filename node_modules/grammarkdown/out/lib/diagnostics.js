"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/*!
 *  Copyright 2015 Ron Buckton (rbuckton@chronicles.org)
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
var core_1 = require("./core");
var tokens_1 = require("./tokens");
exports.Diagnostics = {
    Constant_expected: { code: 1000, message: "Constant expected." },
    _0_expected: { code: 1001, message: "{0} expected." },
    _0_or_1_: { code: 0, message: "{0} or {1}" },
    Unexpected_token_0_: { code: 1002, message: "Unexpected token {0}." },
    Invalid_character: { code: 1003, message: "Invalid character." },
    Unterminated_string_literal: { code: 1004, message: "Unterminated string literal." },
    Invalid_escape_sequence: { code: 1005, message: "Invalid escape sequence." },
    Digit_expected: { code: 1006, message: "Digit expected." },
    Production_expected: { code: 1007, message: "Production expected." },
    Unterminated_identifier_literal: { code: 1008, message: "Unterminated identifier literal." },
    Obsolete_0_: { code: 1009, message: "Obsolete: {0}", warning: true },
    Cannot_find_name_0_: { code: 2000, message: "Cannot find name: '{0}'." },
    Duplicate_identifier_0_: { code: 2001, message: "Duplicate identifier: '{0}'." },
    Duplicate_terminal_0_: { code: 2002, message: "Duplicate terminal: `{0}`." },
    Argument_0_cannot_be_specified_multiple_times: { code: 2003, message: "Argument '{0}' cannot be specified multiple times." },
    Production_0_does_not_have_a_parameter_named_1_: { code: 2004, message: "Production '{0}' does not have a parameter named '{1}'." },
    Production_0_is_missing_parameter_1_All_definitions_of_production_0_must_specify_the_same_formal_parameters: { code: 2006, message: "Production '{0}' is missing parameter '{1}'. All definitions of production '{0}' must specify the same formal parameters." },
    There_is_no_argument_given_for_parameter_0_: { code: 2007, message: "There is no argument given for parameter '{0}'." },
};
var DiagnosticMessages = (function () {
    function DiagnosticMessages() {
        this.nextDiagnosticIndex = 0;
    }
    DiagnosticMessages.prototype.setSourceFile = function (sourceFile) {
        if (!this.sourceFiles) {
            this.sourceFiles = [];
            this.sourceFilesDiagnosticOffset = [];
        }
        var diagnosticOffset = this.count();
        var sourceFileIndex = this.sourceFiles.length;
        this.sourceFiles[sourceFileIndex] = sourceFile;
        this.sourceFilesDiagnosticOffset[sourceFileIndex] = diagnosticOffset;
    };
    DiagnosticMessages.prototype.report = function (pos, message) {
        this.reportDiagnostic(message, Array.prototype.slice.call(arguments, 2), pos);
    };
    DiagnosticMessages.prototype.reportNode = function (node, message) {
        var pos;
        var length;
        if (node) {
            pos = node.pos;
            length = node.end - node.pos;
        }
        this.reportDiagnostic(message, Array.prototype.slice.call(arguments, 2), pos, length, node);
    };
    DiagnosticMessages.prototype.count = function () {
        return this.diagnostics ? this.diagnostics.length : 0;
    };
    DiagnosticMessages.prototype.getMessage = function (diagnosticIndex, options) {
        if (options === void 0) { options = { detailed: true }; }
        var diagnostic = this.diagnostics && this.diagnostics[diagnosticIndex];
        if (diagnostic) {
            var _a = options.detailed, detailed = _a === void 0 ? true : _a;
            var diagnosticMessages = detailed
                ? this.detailedDiagnosticMessages || (this.detailedDiagnosticMessages = new core_1.Dictionary())
                : this.simpleDiagnosticMessages || (this.simpleDiagnosticMessages = new core_1.Dictionary());
            if (core_1.Dictionary.has(diagnosticMessages, diagnosticIndex)) {
                return core_1.Dictionary.get(diagnosticMessages, diagnosticIndex);
            }
            var diagnosticArguments = this.diagnosticsArguments && this.diagnosticsArguments[diagnosticIndex];
            var sourceFile = this.getDiagnosticSourceFile(diagnosticIndex);
            var text = "";
            if (detailed) {
                text += sourceFile ? sourceFile.filename : "";
                if (this.diagnosticsPos && diagnosticIndex in this.diagnosticsPos) {
                    var diagnosticPos = this.diagnosticsPos[diagnosticIndex];
                    if (sourceFile && sourceFile.lineMap) {
                        text += "(" + sourceFile.lineMap.formatPosition(diagnosticPos) + ")";
                    }
                    else {
                        text += "(" + diagnosticPos + ")";
                    }
                }
                text += ": ";
                text += diagnostic.warning ? "warning" : "error";
                text += " GM" + String(diagnostic.code) + ": ";
            }
            var message = diagnostic.message;
            if (diagnosticArguments) {
                message = formatString(message, diagnosticArguments);
            }
            text += message;
            core_1.Dictionary.set(diagnosticMessages, diagnosticIndex, text);
            return text;
        }
        return "";
    };
    DiagnosticMessages.prototype.getDiagnostic = function (diagnosticIndex) {
        return this.diagnostics && this.diagnostics[diagnosticIndex];
    };
    DiagnosticMessages.prototype.getDiagnosticInfos = function (options) {
        var result = [];
        if (this.diagnostics) {
            for (var _i = 0, _a = this.getSortedAndDeduplicatedDiagnosticIndices(); _i < _a.length; _i++) {
                var diagnosticIndex = _a[_i];
                result.push(this.getDiagnosticInfo(diagnosticIndex, options));
            }
        }
        return result;
    };
    DiagnosticMessages.prototype.getDiagnosticInfosForSourceFile = function (sourceFile, options) {
        var result = [];
        if (this.diagnostics) {
            for (var _i = 0, _a = this.getSortedAndDeduplicatedDiagnosticIndices(); _i < _a.length; _i++) {
                var diagnosticIndex = _a[_i];
                if (this.getDiagnosticSourceFile(diagnosticIndex) === sourceFile) {
                    result.push(this.getDiagnosticInfo(diagnosticIndex, options));
                }
            }
        }
        return result;
    };
    DiagnosticMessages.prototype.getDiagnosticInfo = function (diagnosticIndex, options) {
        if (options === void 0) { options = {}; }
        var diagnostic = this.getDiagnostic(diagnosticIndex);
        if (diagnostic) {
            var info = {
                diagnosticIndex: diagnosticIndex,
                code: diagnostic.code,
                warning: diagnostic.warning || false,
                message: diagnostic.message,
                messageArguments: this.getDiagnosticArguments(diagnosticIndex),
                range: this.getDiagnosticRange(diagnosticIndex),
                sourceFile: this.getDiagnosticSourceFile(diagnosticIndex),
                node: this.getDiagnosticNode(diagnosticIndex),
                pos: this.getDiagnosticPos(diagnosticIndex)
            };
            if (options.formatMessage) {
                info.formattedMessage = this.getMessage(diagnosticIndex, { detailed: options.detailedMessage });
            }
            return info;
        }
        return undefined;
    };
    DiagnosticMessages.prototype.getDiagnosticArguments = function (diagnosticIndex) {
        return this.diagnosticsArguments && this.diagnosticsArguments[diagnosticIndex];
    };
    DiagnosticMessages.prototype.getDiagnosticRange = function (diagnosticIndex) {
        var diagnostic = this.getDiagnostic(diagnosticIndex);
        var sourceFile = this.getDiagnosticSourceFile(diagnosticIndex);
        var node = this.getDiagnosticNode(diagnosticIndex);
        var pos = this.getDiagnosticPos(diagnosticIndex);
        if (diagnostic && node || pos > -1) {
            return getDiagnosticRange(node, pos, sourceFile);
        }
        return undefined;
    };
    DiagnosticMessages.prototype.getDiagnosticNode = function (diagnosticIndex) {
        return this.diagnosticsNode && this.diagnosticsNode[diagnosticIndex];
    };
    DiagnosticMessages.prototype.forEach = function (callback) {
        if (this.diagnostics) {
            for (var _i = 0, _a = this.getSortedAndDeduplicatedDiagnosticIndices(); _i < _a.length; _i++) {
                var diagnosticIndex = _a[_i];
                callback(this.getMessage(diagnosticIndex, { detailed: true }), diagnosticIndex);
            }
        }
    };
    DiagnosticMessages.prototype.getSortedAndDeduplicatedDiagnosticIndices = function () {
        if (!this.sortedAndDeduplicatedDiagnosticIndices) {
            var indices = [];
            for (var diagnosticIndex = 0, l = this.diagnostics.length; diagnosticIndex < l; diagnosticIndex++) {
                indices[diagnosticIndex] = diagnosticIndex;
            }
            indices = this.sortDiagnostics(indices);
            indices = this.deduplicateDiagnostics(indices);
            this.sortedAndDeduplicatedDiagnosticIndices = indices;
        }
        return this.sortedAndDeduplicatedDiagnosticIndices;
    };
    DiagnosticMessages.prototype.sortDiagnostics = function (indices) {
        var _this = this;
        return indices.sort(function (left, right) { return _this.compareDiagnostics(left, right); });
    };
    DiagnosticMessages.prototype.compareDiagnostics = function (diagnosticIndex1, diagnosticIndex2) {
        return core_1.compareStrings(this.getDiagnosticSourceFile(diagnosticIndex1).filename, this.getDiagnosticSourceFile(diagnosticIndex2).filename)
            || core_1.compare(this.getDiagnosticPos(diagnosticIndex1), this.getDiagnosticPos(diagnosticIndex2))
            || core_1.compare(this.getDiagnosticLength(diagnosticIndex1), this.getDiagnosticLength(diagnosticIndex2))
            || core_1.compare(this.getDiagnosticErrorLevel(diagnosticIndex1), this.getDiagnosticErrorLevel(diagnosticIndex2))
            || core_1.compare(this.getDiagnosticCode(diagnosticIndex1), this.getDiagnosticCode(diagnosticIndex2))
            || core_1.compareStrings(this.getMessage(diagnosticIndex1), this.getMessage(diagnosticIndex2), /*ignoreCase*/ true);
    };
    DiagnosticMessages.prototype.deduplicateDiagnostics = function (indices) {
        if (indices.length <= 1) {
            return indices;
        }
        var numIndices = indices.length;
        var firstDiagnosticIndex = indices[0];
        var newIndices = [firstDiagnosticIndex];
        var previousDiagnosticIndex = firstDiagnosticIndex;
        for (var i = 1; i < indices.length; i++) {
            var diagnosticIndex = indices[i];
            if (this.compareDiagnostics(previousDiagnosticIndex, diagnosticIndex)) {
                newIndices.push(diagnosticIndex);
                previousDiagnosticIndex = diagnosticIndex;
            }
        }
        return newIndices;
    };
    DiagnosticMessages.prototype.getDiagnosticPos = function (diagnosticIndex) {
        return this.diagnosticsPos && this.diagnosticsPos[diagnosticIndex] || -1;
    };
    DiagnosticMessages.prototype.getDiagnosticLength = function (diagnosticIndex) {
        return this.diagnosticsLength && this.diagnosticsLength[diagnosticIndex] || 0;
    };
    DiagnosticMessages.prototype.getDiagnosticCode = function (diagnosticIndex) {
        var diagnostic = this.getDiagnostic(diagnosticIndex);
        return diagnostic && diagnostic.code || 0;
    };
    DiagnosticMessages.prototype.getDiagnosticErrorLevel = function (diagnosticIndex) {
        var diagnostic = this.getDiagnostic(diagnosticIndex);
        return diagnostic && diagnostic.warning ? 0 : 1;
    };
    DiagnosticMessages.prototype.reportDiagnostic = function (message, args, pos, length, node) {
        this.sortedAndDeduplicatedDiagnosticIndices = undefined;
        if (!this.diagnostics) {
            this.diagnostics = [];
        }
        var diagnosticIndex = this.diagnostics.length;
        this.diagnostics[diagnosticIndex] = message;
        if (args.length === 1 && args[0] instanceof Array) {
            args = args[0];
        }
        if (args.length > 0) {
            if (!this.diagnosticsArguments) {
                this.diagnosticsArguments = [];
            }
            this.diagnosticsArguments[diagnosticIndex] = args;
        }
        if (pos !== undefined) {
            if (!this.diagnosticsPos) {
                this.diagnosticsPos = [];
            }
            this.diagnosticsPos[diagnosticIndex] = pos;
        }
        if (length !== undefined) {
            if (!this.diagnosticsLength) {
                this.diagnosticsLength = [];
            }
            this.diagnosticsLength[diagnosticIndex] = length;
        }
        if (node !== undefined) {
            if (!this.diagnosticsNode) {
                this.diagnosticsNode = [];
            }
            this.diagnosticsNode[diagnosticIndex] = node;
        }
    };
    DiagnosticMessages.prototype.getDiagnosticSourceFile = function (diagnosticIndex) {
        if (this.sourceFiles) {
            var offset = core_1.binarySearch(this.sourceFilesDiagnosticOffset, diagnosticIndex);
            if (offset < 0) {
                offset = (~offset) - 1;
            }
            while (offset + 1 < this.sourceFiles.length && this.sourceFilesDiagnosticOffset[offset + 1] === diagnosticIndex) {
                offset++;
            }
            return this.sourceFiles[offset];
        }
        return undefined;
    };
    return DiagnosticMessages;
}());
exports.DiagnosticMessages = DiagnosticMessages;
var NullDiagnosticMessages = (function (_super) {
    __extends(NullDiagnosticMessages, _super);
    function NullDiagnosticMessages() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(NullDiagnosticMessages, "instance", {
        get: function () {
            return this._instance || (this._instance = new NullDiagnosticMessages());
        },
        enumerable: true,
        configurable: true
    });
    NullDiagnosticMessages.prototype.reportCore = function (message, arg0, arg1) { return 0; };
    NullDiagnosticMessages.prototype.report = function (pos, message, arg0, arg1) { return 0; };
    NullDiagnosticMessages.prototype.reportNode = function (node, message, arg0, arg1) { return 0; };
    NullDiagnosticMessages.prototype.count = function () { return 0; };
    NullDiagnosticMessages.prototype.getMessage = function (diagnosticIndex) { return ""; };
    NullDiagnosticMessages.prototype.getDiagnostic = function (diagnosticIndex) { return undefined; };
    NullDiagnosticMessages.prototype.getDiagnosticNode = function (diagnosticIndex) { return undefined; };
    NullDiagnosticMessages.prototype.forEach = function (callback) { };
    return NullDiagnosticMessages;
}(DiagnosticMessages));
exports.NullDiagnosticMessages = NullDiagnosticMessages;
var LineMap = (function () {
    function LineMap(text) {
        this.text = text;
    }
    Object.defineProperty(LineMap.prototype, "lineCount", {
        get: function () {
            this.computeLineStarts();
            return this.lineStarts.length;
        },
        enumerable: true,
        configurable: true
    });
    /* @obsolete */ /* @internal */ LineMap.prototype.formatPosition = function (pos) { return this.formatOffset(pos); };
    /* @obsolete */ /* @internal */ LineMap.prototype.getPositionOfLineAndCharacter = function (lineAndCharacter) { return this.offsetAt(lineAndCharacter); };
    /* @obsolete */ /* @internal */ LineMap.prototype.getLineAndCharacterOfPosition = function (pos) { return this.positionAt(pos); };
    LineMap.prototype.formatOffset = function (pos) {
        this.computeLineStarts();
        var lineNumber = core_1.binarySearch(this.lineStarts, pos);
        if (lineNumber < 0) {
            // If the actual position was not found,
            // the binary search returns the negative value of the next line start
            // e.g. if the line starts at [5, 10, 23, 80] and the position requested was 20
            // then the search will return -2
            lineNumber = (~lineNumber) - 1;
        }
        return lineNumber + 1 + "," + (pos - this.lineStarts[lineNumber] + 1);
    };
    LineMap.prototype.offsetAt = function (position) {
        this.computeLineStarts();
        if (position.line < 0 ||
            position.character < 0 ||
            position.line >= this.lineStarts.length) {
            return -1;
        }
        var pos = this.lineStarts[position.line] + position.character;
        var lineEnd = position.line + 1 < this.lineStarts.length
            ? this.lineStarts[position.line + 1]
            : this.text.length;
        if (pos >= lineEnd) {
            return -1;
        }
        if (this.text.charCodeAt(pos) === 10 /* LineFeed */ ||
            this.text.charCodeAt(pos) === 13 /* CarriageReturn */) {
            return -1;
        }
        return pos;
    };
    LineMap.prototype.positionAt = function (offset) {
        this.computeLineStarts();
        var lineNumber = core_1.binarySearch(this.lineStarts, offset);
        if (lineNumber < 0) {
            // If the actual position was not found,
            // the binary search returns the negative value of the next line start
            // e.g. if the line starts at [5, 10, 23, 80] and the position requested was 20
            // then the search will return -2
            lineNumber = (~lineNumber) - 1;
        }
        return { line: lineNumber, character: offset - this.lineStarts[lineNumber] };
    };
    LineMap.prototype.computeLineStarts = function () {
        if (this.lineStarts) {
            return;
        }
        var lineStarts = [];
        var lineStart = 0;
        for (var pos = 0; pos < this.text.length;) {
            var ch = this.text.charCodeAt(pos++);
            switch (ch) {
                case 13 /* CarriageReturn */:
                    if (this.text.charCodeAt(pos) === 10 /* LineFeed */) {
                        pos++;
                    }
                case 10 /* LineFeed */:
                case 8232 /* LineSeparator */:
                case 8233 /* ParagraphSeparator */:
                case 133 /* NextLine */:
                    lineStarts.push(lineStart);
                    lineStart = pos;
                    break;
            }
        }
        lineStarts.push(lineStart);
        this.lineStarts = lineStarts;
    };
    LineMap.prototype.isLineBreak = function (ch) {
        return ch === 13 /* CarriageReturn */
            || ch === 10 /* LineFeed */
            || ch === 8232 /* LineSeparator */
            || ch === 8233 /* ParagraphSeparator */
            || ch === 133 /* NextLine */;
    };
    return LineMap;
}());
exports.LineMap = LineMap;
function getDiagnosticRange(diagnosticNode, diagnosticPos, sourceFile) {
    return {
        start: positionOfStart(diagnosticNode, diagnosticPos, sourceFile),
        end: positionOfEnd(diagnosticNode, diagnosticPos, sourceFile)
    };
}
function positionOfStart(diagnosticNode, diagnosticPos, sourceFile) {
    return positionAt(diagnosticNode ? diagnosticNode.pos : diagnosticPos, sourceFile);
}
function positionOfEnd(diagnosticNode, diagnosticPos, sourceFile) {
    return positionAt(diagnosticNode ? diagnosticNode.end : diagnosticPos, sourceFile);
}
function positionAt(diagnosticPos, sourceFile) {
    return sourceFile && sourceFile.lineMap
        ? sourceFile.lineMap.positionAt(diagnosticPos)
        : { line: 0, character: diagnosticPos };
}
function formatString(format) {
    var args = Array.prototype.slice.call(arguments, 1);
    if (args.length === 1 && args[0] instanceof Array) {
        args = args[0];
    }
    return format.replace(/{(\d+)}/g, function (_, index) { return args[index]; });
}
exports.formatString = formatString;
function formatList(tokens) {
    if (tokens.length <= 0) {
        return "";
    }
    else if (tokens.length === 1) {
        return tokens_1.tokenToString(tokens[0], /*quoted*/ true);
    }
    else if (tokens.length === 2) {
        return formatString(exports.Diagnostics._0_or_1_.message, tokens_1.tokenToString(tokens[0], /*quoted*/ true), tokens_1.tokenToString(tokens[1], /*quoted*/ true));
    }
    else {
        var text = "";
        for (var i = 0; i < tokens.length - 1; i++) {
            if (i > 0) {
                text += " ";
            }
            text += tokens_1.tokenToString(tokens[i], /*quoted*/ true);
            text += ",";
        }
        return formatString(exports.Diagnostics._0_or_1_.message, text, tokens_1.tokenToString(tokens[tokens.length - 1], /*quoted*/ true));
    }
}
exports.formatList = formatList;
//# sourceMappingURL=diagnostics.js.map
