import { SourceFile, Node } from "./nodes";
import { Position } from "./core";
import { SyntaxKind } from "./tokens";
export declare class NodeNavigator {
    private sourceFile;
    private nodeStack;
    private shapeStack;
    private edgeStack;
    private arrayStack;
    private offsetStack;
    private currentDepth;
    private currentNode;
    private currentEdge;
    private currentShape;
    private currentOffset;
    private currentArray;
    private parentNode;
    private parentShape;
    private hasAnyChildren;
    private copyOnNavigate;
    constructor(sourceFile: SourceFile);
    constructor(other: NodeNavigator);
    private initialize(sourceFile, nodeStack, shapeStack, edgeStack, arrayStack, offsetStack);
    clone(): NodeNavigator;
    getRoot(): SourceFile;
    getParent(): Node;
    getNode(): Node<SyntaxKind>;
    getKind(): SyntaxKind;
    getName(): string;
    getArray(): Node[];
    getOffset(): number;
    getDepth(): number;
    isArray(): boolean;
    hasChildren(predicate?: (node: Node) => boolean): boolean;
    private hasChild(predicate);
    hasAncestor(predicate?: (node: Node) => boolean): boolean;
    isSamePosition(other: NodeNavigator): boolean;
    moveToPosition(position: Position): boolean;
    private moveToPositionWorker(pos);
    moveTo(other: NodeNavigator): boolean;
    moveToRoot(): boolean;
    moveToParent(predicate?: (node: Node) => boolean): boolean;
    moveToAncestorOrSelf(predicate: (node: Node) => boolean): boolean;
    moveToAncestor(predicate: (node: Node) => boolean): boolean;
    moveToSourceElement(): boolean;
    moveToDeclaration(): boolean;
    moveToName(): boolean;
    moveToFirstChild(): boolean;
    moveToFirstChild(name: string): boolean;
    moveToFirstChild(predicate: (node: Node) => boolean): boolean;
    moveToLastChild(): boolean;
    moveToLastChild(name: string): boolean;
    moveToLastChild(predicate: (node: Node) => boolean): boolean;
    moveToFirstElement(predicate?: (node: Node) => boolean): boolean;
    moveToPreviousElement(predicate?: (node: Node) => boolean): boolean;
    moveToNextElement(predicate?: (node: Node) => boolean): boolean;
    moveToLastElement(predicate?: (node: Node) => boolean): boolean;
    moveToFirstSibling(): boolean;
    moveToFirstSibling(name: string): boolean;
    moveToFirstSibling(predicate: (node: Node) => boolean): boolean;
    moveToPreviousSibling(): boolean;
    moveToPreviousSibling(name: string): boolean;
    moveToPreviousSibling(predicate: (node: Node) => boolean): boolean;
    moveToNextSibling(): boolean;
    moveToNextSibling(name: string): boolean;
    moveToNextSibling(predicate: (node: Node) => boolean): boolean;
    moveToLastSibling(): boolean;
    moveToLastSibling(name: string): boolean;
    moveToLastSibling(predicate: (node: Node) => boolean): boolean;
    private getEdge();
    private beforeNavigate();
    private afterNavigate();
    private pushEdge();
    private setEdge(node, edge, array, offset);
    private popEdge();
    private moveToChild(initializer, seekDirection, predicateOrName);
    private moveToElement(currentArrayInitializer, seekDirection, currentArray, currentOffset, predicateOrName);
    private moveToSibling(currentEdgeInitializer, currentArrayInitializer, nextArrayInitializer, seekDirection, predicateOrName);
    private reset();
}
