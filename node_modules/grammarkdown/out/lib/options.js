"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var fs_1 = require("fs");
var core_1 = require("./core");
var EmitFormat;
(function (EmitFormat) {
    EmitFormat[EmitFormat["markdown"] = 0] = "markdown";
    EmitFormat[EmitFormat["html"] = 1] = "html";
    EmitFormat[EmitFormat["ecmarkup"] = 2] = "ecmarkup";
})(EmitFormat = exports.EmitFormat || (exports.EmitFormat = {}));
function getDefaultOptions() {
    return { format: EmitFormat.markdown };
}
exports.getDefaultOptions = getDefaultOptions;
function parse(options, args) {
    if (args === void 0) { args = process.argv.slice(2); }
    var known = createKnownOptionMaps(new core_1.Dictionary(options));
    var raw = { args: [], rest: [] };
    var messages = [];
    var result;
    result = parseArguments(args, known, raw, messages);
    if (result === ParseResult.Success) {
        result = expandArguments(known, raw, messages);
        if (result === ParseResult.Success) {
            Object.freeze(raw.rest);
            Object.freeze(raw.args);
            Object.freeze(raw);
            var parsed = { argv: args.slice(0) };
            result = evaluateArguments(parsed, known, raw, messages);
            if (result === ParseResult.Success) {
                return parsed;
            }
        }
    }
    printErrors(messages);
}
exports.parse = parse;
var emptyArray = [];
var UsageWriter = (function () {
    function UsageWriter(margin, padding) {
        this.margin = margin;
        this.padding = padding;
        this.remainder = 120 - margin - padding;
        this.marginText = padRight("", margin);
        this.paddingText = padRight("", padding);
    }
    UsageWriter.prototype.writeOption = function (left, right) {
        var leftLines = left ? this.fit(left, this.margin) : emptyArray;
        var rightLines = right ? this.fit(right, this.remainder) : emptyArray;
        var lineCount = Math.max(leftLines.length, rightLines.length);
        for (var i = 0; i < lineCount; ++i) {
            var line = "";
            if (i < leftLines.length) {
                line += leftLines[i];
            }
            if (i < rightLines.length) {
                line = padRight(line, this.margin + this.padding);
                line += rightLines[i];
            }
            console.log(line);
        }
    };
    UsageWriter.prototype.writeln = function (text) {
        if (text === void 0) { text = ""; }
        console.log(text);
    };
    UsageWriter.prototype.fit = function (text, width) {
        var lines = [];
        var pos = 0, len = text.length;
        while (pos < len) {
            var ch = text.charCodeAt(pos);
            if (ch === 13 /* CarriageReturn */ || ch === 10 /* LineFeed */) {
                pos++;
                if (ch === 13 /* CarriageReturn */ && pos < len && text.charCodeAt(pos) === 10 /* LineFeed */) {
                    pos++;
                }
                lines.push("");
                continue;
            }
            var end = pos + width;
            if (end >= len) {
                lines.push(text.substr(pos));
                break;
            }
            while (end > pos && !isWhiteSpace(text.charCodeAt(end)))
                end--;
            while (end > pos && isWhiteSpace(text.charCodeAt(end), true))
                end--;
            if (end <= pos) {
                lines.push(text.substr(pos, width));
                pos += width;
            }
            else {
                lines.push(text.substring(pos, end));
                pos = end;
            }
            while (pos < len && isWhiteSpace(text.charCodeAt(pos), true))
                pos++;
        }
        return lines;
    };
    return UsageWriter;
}());
exports.UsageWriter = UsageWriter;
function usage(options, margin, printHeader) {
    if (margin === void 0) { margin = 0; }
    var optionsDictionary = new core_1.Dictionary(options);
    var knownOptions = [];
    var hasShortNames = false;
    for (var key in optionsDictionary) {
        var option = importKnownOption(key, optionsDictionary[key]);
        if (option.hidden) {
            continue;
        }
        var size = option.longName.length + 3;
        if (option.shortName) {
            hasShortNames = true;
            size += 4;
        }
        if (option.param) {
            size += 1;
        }
        if (size > margin) {
            margin = size;
        }
        knownOptions.push(option);
    }
    var writer = new UsageWriter(margin, 1);
    if (printHeader) {
        printHeader(writer);
    }
    knownOptions.sort(compareKnownOptions);
    var descriptionSize = 120 - margin;
    var marginText = padRight("", margin);
    for (var _i = 0, knownOptions_1 = knownOptions; _i < knownOptions_1.length; _i++) {
        var option = knownOptions_1[_i];
        var left = " ";
        if (option.shortName) {
            left += "-" + option.shortName + ", ";
        }
        else if (hasShortNames) {
            left += "    ";
        }
        left += "--" + option.longName;
        if (option.param) {
            left += " " + option.param;
        }
        left = padRight(left, margin);
        writer.writeOption(left, option.description);
    }
}
exports.usage = usage;
function padLeft(text, size, char) {
    if (char === void 0) { char = " "; }
    while (text.length < size)
        text = char + text;
    return text;
}
function padRight(text, size, char) {
    if (char === void 0) { char = " "; }
    while (text.length < size)
        text += char;
    return text;
}
function printErrors(messages) {
    for (var _i = 0, messages_1 = messages; _i < messages_1.length; _i++) {
        var message = messages_1[_i];
        console.error(message);
    }
}
function compareKnownOptions(x, y) {
    var xName = x.longName.toLowerCase();
    var yName = y.longName.toLowerCase();
    return xName.localeCompare(yName);
}
function importTypeMap(dict) {
    var copy = core_1.Dictionary.turn(dict, function (memo, value, key) { return core_1.Dictionary.set(memo, String(key), value); }, new core_1.Dictionary());
    Object.freeze(copy);
    return copy;
}
function importKnownOption(key, option) {
    var copy = { longName: key };
    if (typeof option.longName === "string")
        copy.longName = option.longName;
    if (typeof option.shortName === "string" && option.shortName.length > 0)
        copy.shortName = option.shortName.substr(0, 1);
    if (typeof option.param === "string")
        copy.param = option.param;
    if (typeof option.type === "string")
        copy.type = option.type;
    if (typeof option.type === "object")
        copy.type = importTypeMap(option.type);
    if (typeof option.many === "boolean")
        copy.many = option.many;
    if (typeof option.description === "string")
        copy.description = option.description;
    if (typeof option.error === "string")
        copy.error = option.error;
    if (typeof option.aliasFor === "string")
        copy.aliasFor = option.aliasFor;
    if (typeof option.hidden === "boolean" && option.hidden)
        copy.hidden = option.hidden;
    if (typeof option.isUsage === "boolean" && option.isUsage)
        copy.isUsage = option.isUsage;
    if (typeof option.validate === "function")
        copy.validate = option.validate;
    if (typeof option.convert === "function")
        copy.convert = option.convert;
    Object.freeze(copy);
    return copy;
}
function createKnownOptionMaps(options) {
    var longNames = new core_1.Dictionary();
    var shortNames = new core_1.Dictionary();
    for (var key in options) {
        var rawOption = options[key];
        if (rawOption) {
            var knownOption = importKnownOption(key, rawOption);
            core_1.Dictionary.set(longNames, knownOption.longName.toLowerCase(), knownOption);
            if (knownOption.shortName) {
                core_1.Dictionary.set(shortNames, knownOption.shortName, knownOption);
            }
        }
    }
    var maps = { longNames: longNames, shortNames: shortNames };
    Object.freeze(longNames);
    Object.freeze(shortNames);
    Object.freeze(maps);
    return maps;
}
var ParseResult;
(function (ParseResult) {
    ParseResult[ParseResult["Success"] = 0] = "Success";
    ParseResult[ParseResult["Error"] = 1] = "Error";
})(ParseResult || (ParseResult = {}));
function parseArguments(args, known, raw, messages) {
    var argc = args.length, argi = 0;
    while (argi < argc) {
        var arg = args[argi++];
        var ch = arg.charCodeAt(0);
        if (ch === 64 /* At */) {
            var result = parseResponseFile(arg.substr(1), known, raw, messages);
            if (result !== ParseResult.Success) {
                return result;
            }
        }
        else if (ch === 45 /* Minus */) {
            ch = arg.charCodeAt(1);
            var colonIndex = arg.indexOf(":");
            var hasInlineValue = colonIndex > 0;
            var shortName = ch !== 45 /* Minus */;
            var rawKey = arg.substring(shortName ? 1 : 2, hasInlineValue ? colonIndex : arg.length);
            var match = matchKnownOption(known, rawKey, shortName);
            switch (match.cardinality) {
                case "none":
                    messages.push("Unrecognized option: " + rawKey + ".");
                    return ParseResult.Error;
                case "many":
                    messages.push("Unrecognized option: " + rawKey + ". Did you mean:");
                    for (var _i = 0, _a = match.candidates; _i < _a.length; _i++) {
                        var option_1 = _a[_i];
                        messages.push("    --" + option_1.longName);
                    }
                    return ParseResult.Error;
            }
            var option = match.option;
            var formattedKey = shortName ? "-" + option.shortName : "--" + option.longName;
            var valueRequired = optionRequiresValue(option);
            var value = void 0;
            if (valueRequired || hasInlineValue) {
                if (hasInlineValue) {
                    value = arg.substr(colonIndex + 1);
                }
                else {
                    if (argi >= argc) {
                        messages.push("Option '" + formattedKey + "' expects an argument.");
                        return ParseResult.Error;
                    }
                    value = args[argi++];
                }
                if (value.length > 0) {
                    ch = value.charCodeAt(0);
                    if (ch === 34 /* DoubleQuote */) {
                        if (value.length > 1 && value.charCodeAt(value.length - 1) === ch) {
                            value = value.substr(1, value.length - 2);
                        }
                    }
                }
                if (valueRequired) {
                    if (value.length === 0 || value === "\"\"" || value === "''") {
                        messages.push("Option '" + formattedKey + "' expects an argument.");
                        return ParseResult.Error;
                    }
                }
            }
            if (option.type === "boolean") {
                if (!value) {
                    value = "true";
                }
            }
            var rawArgument = {
                rawKey: rawKey,
                formattedKey: formattedKey,
                value: value,
                option: option
            };
            Object.freeze(rawArgument);
            raw.args.push(rawArgument);
        }
        else {
            if (ch === 34 /* DoubleQuote */) {
                if (arg.length > 1 && arg.charCodeAt(arg.length - 1) === ch) {
                    arg = arg.substr(1, arg.length - 2);
                }
            }
            raw.rest.push(arg);
        }
    }
    return ParseResult.Success;
}
function parseResponseFile(file, known, raw, messages) {
    var text;
    try {
        text = fs_1.readFileSync(file, "utf8");
    }
    catch (e) {
        messages.push("File '" + file + "'' not found.");
        return ParseResult.Error;
    }
    var args = [];
    var pos = 0;
    var len = text.length;
    while (pos < len) {
        var ch = text.charCodeAt(pos);
        if (isWhiteSpace(ch)) {
            pos++;
            continue;
        }
        var start = pos;
        if (ch === 34 /* DoubleQuote */) {
            pos++;
            while (pos < len) {
                ch = text.charCodeAt(pos);
                if (ch === 34 /* DoubleQuote */) {
                    break;
                }
                pos++;
            }
            args.push(text.substring(start, pos++));
        }
        else {
            pos++;
            while (pos < len) {
                ch = text.charCodeAt(pos);
                if (!isWhiteSpace(ch)) {
                    pos++;
                }
            }
            args.push(text.substring(start, pos));
        }
    }
    return parseArguments(args, known, raw, messages);
}
function isWhiteSpace(ch, excludeLineTerminator) {
    switch (ch) {
        case 10 /* LineFeed */:
        case 13 /* CarriageReturn */:
            return !excludeLineTerminator;
        case 32 /* Space */:
        case 9 /* Tab */:
        case 11 /* VerticalTab */:
        case 12 /* FormFeed */:
            return true;
    }
    return false;
}
function optionRequiresValue(option) {
    switch (option.type) {
        case undefined:
        case "":
        case "boolean":
            return false;
        default:
            return true;
    }
}
function matchKnownOption(known, key, shortName) {
    if (shortName) {
        var option = core_1.Dictionary.get(known.shortNames, key);
        if (option) {
            return { cardinality: "one", option: option };
        }
    }
    else {
        var keyLower = key.toLowerCase();
        if (core_1.Dictionary.has(known.longNames, keyLower)) {
            var option = core_1.Dictionary.get(known.longNames, keyLower);
            if (option) {
                return { cardinality: "one", option: option };
            }
        }
        else {
            var keyLen = keyLower.length;
            var candidates = void 0;
            var knownKey = void 0;
            for (knownKey in known.longNames) {
                if (core_1.Dictionary.has(known.longNames, knownKey) &&
                    knownKey.length > keyLen &&
                    knownKey.substr(0, keyLen) === keyLower) {
                    if (!candidates) {
                        candidates = [];
                    }
                    candidates.push(core_1.Dictionary.get(known.longNames, knownKey));
                }
            }
            if (candidates) {
                if (candidates.length === 1) {
                    var option = candidates[0];
                    return { cardinality: "one", option: option };
                }
                else if (candidates.length > 1) {
                    return { cardinality: "many", candidates: candidates };
                }
            }
        }
    }
    return { cardinality: "none" };
}
function expandArguments(known, raw, messages) {
    for (var i = 0; i < raw.args.length; ++i) {
        var arg = raw.args[i];
        var option = arg.option;
        if (option.aliasFor) {
            var args = option.aliasFor;
            if (arg.value) {
                args = args.concat([arg.value]);
            }
            if (parseArguments(args, known, raw, messages) === ParseResult.Error) {
                return ParseResult.Error;
            }
        }
    }
    return ParseResult.Success;
}
function evaluateArguments(parsed, known, raw, messages) {
    for (var _i = 0, _a = raw.args; _i < _a.length; _i++) {
        var arg = _a[_i];
        var formattedKey = arg.formattedKey, value = arg.value, option = arg.option;
        if (option.aliasFor) {
            continue;
        }
        var type = typeof option.type;
        if (type === "string") {
            type = option.type;
        }
        if (option.validate && !option.validate(option.longName, value, raw)) {
            if (option.error) {
                messages.push(option.error);
            }
            else {
                messages.push("Invalid argument for option '" + formattedKey + "'.");
            }
            return ParseResult.Error;
        }
        var booleanValue = void 0;
        var numberValue = void 0;
        switch (type) {
            case "file":
            case "string":
                break;
            case "boolean":
                if (value) {
                    value = value.toLowerCase();
                    if (!/^(true|false)$/.test(value)) {
                        if (option.error) {
                            messages.push(option.error);
                        }
                        else {
                            messages.push("Invalid argument for option '" + formattedKey + "'. Expected either 'true' or 'false'.");
                        }
                        return ParseResult.Error;
                    }
                    booleanValue = value === "true";
                }
                else {
                    booleanValue = true;
                }
                break;
            case "number":
                if (value) {
                    numberValue = parseFloat(value);
                    if (isNaN(numberValue) || !isFinite(numberValue)) {
                        if (option.error) {
                            messages.push(option.error);
                        }
                        else {
                            messages.push("Invalid argument for option '" + formattedKey + "'. Expected a finite number.");
                        }
                        return ParseResult.Error;
                    }
                }
                break;
            case "object":
                if (value) {
                    var type_1 = option.type;
                    var result = core_1.Dictionary.get(type_1, value);
                    if (result === undefined) {
                        var valueLower = value.toLowerCase();
                        result = core_1.Dictionary.get(type_1, valueLower);
                        if (!result) {
                            for (var key in type_1) {
                                if (key.toLowerCase() === valueLower) {
                                    result = core_1.Dictionary.get(type_1, key);
                                    break;
                                }
                            }
                        }
                    }
                    if (result === undefined) {
                        if (option.error) {
                            messages.push(option.error);
                        }
                        else {
                            messages.push("Invalid argument for option '" + formattedKey + "'.");
                        }
                        return ParseResult.Error;
                    }
                    value = result;
                }
                break;
        }
        if (option.convert) {
            value = option.convert(option.longName, value, raw);
        }
        else {
            switch (option.type) {
                case "boolean":
                    value = booleanValue;
                    break;
                case "number":
                    value = numberValue;
                    break;
            }
        }
        parsed[option.longName] = value;
    }
    parsed.rest = raw.rest.slice(0);
    return ParseResult.Success;
}
//# sourceMappingURL=options.js.map
