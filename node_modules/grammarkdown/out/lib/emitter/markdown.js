"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var emitter_1 = require("./emitter");
var tokens_1 = require("../tokens");
var MarkdownEmitter = (function (_super) {
    __extends(MarkdownEmitter, _super);
    function MarkdownEmitter() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.extension = ".md";
        return _this;
    }
    MarkdownEmitter.prototype.emitKeyword = function (node) {
        if (node) {
            this.writer.write("**");
            _super.prototype.emitKeyword.call(this, node);
            this.writer.write("**");
        }
    };
    MarkdownEmitter.prototype.emitProduction = function (node) {
        var linkId = this.resolver.getProductionLinkId(node.name);
        this.writer.write("&emsp;&emsp;");
        this.emitLinkAnchor(linkId);
        this.writer.write("*");
        this.emitIdentifier(node.name);
        this.writer.write("*");
        this.emitNode(node.parameterList);
        this.writer.write(" **");
        this.emitToken(node.colonToken);
        this.writer.write("**");
        if (node.body && node.body.kind !== tokens_1.SyntaxKind.RightHandSideList) {
            this.writer.write(" ");
        }
        this.emitNode(node.body);
        this.writer.writeln();
        this.writer.write("  ");
        this.writer.writeln();
    };
    MarkdownEmitter.prototype.emitParameterList = function (node) {
        this.writer.write("<sub>[");
        for (var i = 0; i < node.elements.length; ++i) {
            if (i > 0) {
                this.writer.write(", ");
            }
            this.emitNode(node.elements[i]);
        }
        this.writer.write("]</sub>");
    };
    MarkdownEmitter.prototype.emitParameter = function (node) {
        this.emitIdentifier(node.name);
    };
    MarkdownEmitter.prototype.emitOneOfList = function (node) {
        this.writer.write("**one of**");
        var terminals = node.terminals;
        if (terminals && terminals.length > 0) {
            if (node.openIndentToken) {
                // get the maximum size for a terminal
                var width = 5;
                for (var _i = 0, terminals_1 = terminals; _i < terminals_1.length; _i++) {
                    var terminal = terminals_1[_i];
                    if (terminal.text.length > width) {
                        width = terminal.text.length;
                    }
                }
                this.writer.write("  ");
                this.writer.writeln();
                this.writer.write("<pre>");
                var columns = Math.floor(50 / width);
                var pad = 0;
                for (var i = 0; i < terminals.length; ++i) {
                    var terminal = terminals[i];
                    if (i % columns === 0) {
                        if (i > 0) {
                            this.writer.write("  ");
                            this.writer.writeln();
                        }
                        this.writer.write("&emsp;&emsp;&emsp;");
                    }
                    else {
                        for (var j = 0; j <= pad; ++j) {
                            this.writer.write(" ");
                        }
                    }
                    this.writer.write("<code>");
                    this.writer.write(this.encode(terminal.text));
                    this.writer.write("</code>");
                    pad = width - terminal.text.length;
                }
                this.writer.write("</pre>");
            }
            else {
                this.writer.write(" ");
                for (var i = 0; i < node.terminals.length; ++i) {
                    if (i > 0) {
                        this.writer.write("&emsp;");
                    }
                    this.emitNode(node.terminals[i]);
                }
                this.writer.write("  ");
            }
        }
    };
    MarkdownEmitter.prototype.emitRightHandSideList = function (node) {
        this.writer.write("  ");
        for (var _i = 0, _a = node.elements; _i < _a.length; _i++) {
            var rhs = _a[_i];
            this.writer.writeln();
            this.writer.write("&emsp;&emsp;&emsp;");
            this.emitNode(rhs);
        }
    };
    MarkdownEmitter.prototype.emitRightHandSide = function (node) {
        var linkId = this.resolver.getRightHandSideLinkId(node, /*includePrefix*/ true);
        this.emitLinkAnchor(linkId);
        _super.prototype.emitRightHandSide.call(this, node);
        this.emitTrailingHtmlTriviaOfNode(node);
        this.writer.write("  ");
    };
    MarkdownEmitter.prototype.emitSymbolSpan = function (node) {
        this.emitNode(node.symbol);
        if (node.next) {
            this.writer.write("&emsp;");
            this.emitNode(node.next);
        }
    };
    MarkdownEmitter.prototype.emitTerminal = function (node) {
        this.writer.write("`` ");
        this.writer.write(node.text);
        this.writer.write(" ``");
        if (node.questionToken) {
            this.writer.write("<sub>opt</sub>");
        }
    };
    MarkdownEmitter.prototype.emitNonterminal = function (node) {
        var linkId = this.resolver.getProductionLinkId(node.name);
        this.writer.write("*");
        this.emitNodeWithLink(node.name, linkId);
        this.writer.write("*");
        this.emitNode(node.argumentList);
        if (node.questionToken) {
            this.writer.write("<sub>opt</sub>");
        }
    };
    MarkdownEmitter.prototype.emitArgumentList = function (node) {
        this.writer.write("<sub>[");
        for (var i = 0; i < node.elements.length; ++i) {
            if (i > 0) {
                this.writer.write(", ");
            }
            this.emitNode(node.elements[i]);
        }
        this.writer.write("]</sub>");
    };
    MarkdownEmitter.prototype.emitArgument = function (node) {
        this.emitToken(node.operatorToken);
        this.emitNode(node.name);
    };
    MarkdownEmitter.prototype.emitUnicodeCharacterLiteral = function (node) {
        this.writer.write(this.encode(node.text));
        if (node.questionToken) {
            this.writer.write("<sub>opt</sub>");
        }
    };
    MarkdownEmitter.prototype.emitEmptyAssertion = function (node) {
        this.writer.write("[empty]");
    };
    MarkdownEmitter.prototype.emitSymbolSet = function (node) {
        this.writer.write("{");
        for (var i = 0; i < node.elements.length; ++i) {
            if (i > 0) {
                this.writer.write(",");
            }
            this.writer.write(" ");
            this.emitNode(node.elements[i]);
        }
        this.writer.write(" }");
    };
    MarkdownEmitter.prototype.emitLookaheadAssertion = function (node) {
        switch (node.operatorToken.kind) {
            case tokens_1.SyntaxKind.ExclamationEqualsToken:
            case tokens_1.SyntaxKind.NotEqualToToken:
                this.writer.write("[lookahead \u2260 ");
                break;
            case tokens_1.SyntaxKind.EqualsToken:
            case tokens_1.SyntaxKind.EqualsEqualsToken:
                this.writer.write("[lookahead = ");
                break;
            case tokens_1.SyntaxKind.LessThanMinusToken:
            case tokens_1.SyntaxKind.ElementOfToken:
                this.writer.write("[lookahead \u2208 ");
                break;
            case tokens_1.SyntaxKind.LessThanExclamationToken:
            case tokens_1.SyntaxKind.NotAnElementOfToken:
                this.writer.write("[lookahead \u2209 ");
                break;
        }
        this.emitNode(node.lookahead);
        this.writer.write("]");
    };
    MarkdownEmitter.prototype.emitLexicalGoalAssertion = function (node) {
        var linkId = this.resolver.getProductionLinkId(node.symbol);
        this.writer.write("[lexical goal ");
        this.emitNodeWithLink(node.symbol, linkId);
        this.writer.write("]");
    };
    MarkdownEmitter.prototype.emitNoSymbolHereAssertion = function (node) {
        this.writer.write("[no ");
        if (node.symbols) {
            for (var i = 0; i < node.symbols.length; ++i) {
                if (i > 0) {
                    this.writer.write(" or ");
                }
                this.emitNode(node.symbols[i]);
            }
        }
        this.writer.write(" here]");
    };
    MarkdownEmitter.prototype.emitParameterValueAssertion = function (node) {
        this.writer.write("[");
        this.emitToken(node.operatorToken);
        this.emitNode(node.name);
        this.writer.write("]");
    };
    MarkdownEmitter.prototype.emitProseAssertion = function (node) {
        for (var _i = 0, _a = node.fragments; _i < _a.length; _i++) {
            var fragment = _a[_i];
            this.emitNode(fragment);
        }
    };
    MarkdownEmitter.prototype.emitUnicodeCharacterRange = function (node) {
        this.emitNode(node.left);
        this.writer.write(" **through** ");
        this.emitNode(node.right);
    };
    MarkdownEmitter.prototype.emitButNotSymbol = function (node) {
        this.emitNode(node.left);
        this.writer.write(" **but not** ");
        this.emitNode(node.right);
    };
    MarkdownEmitter.prototype.emitOneOfSymbol = function (node) {
        this.writer.write("**one of** ");
        for (var i = 0; i < node.symbols.length; ++i) {
            if (i > 0) {
                this.writer.write(" **or** ");
            }
            this.emitNode(node.symbols[i]);
        }
    };
    MarkdownEmitter.prototype.emitTextContent = function (node) {
        var text = node.text;
        this.writer.write(text);
    };
    MarkdownEmitter.prototype.emitLinkAnchor = function (linkId) {
        if (linkId) {
            this.writer.write("<a name=\"" + linkId + "\"></a>");
        }
    };
    MarkdownEmitter.prototype.emitNodeWithLink = function (node, linkId) {
        if (linkId) {
            this.writer.write("[");
            this.emitNode(node);
            this.writer.write("](#" + linkId + ")");
        }
        else {
            this.emitNode(node);
        }
    };
    return MarkdownEmitter;
}(emitter_1.Emitter));
exports.MarkdownEmitter = MarkdownEmitter;
//# sourceMappingURL=markdown.js.map
