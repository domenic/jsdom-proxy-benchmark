import { TextRange } from "./core";
import { LineMap } from "./diagnostics";
import { SyntaxKind, ProseFragmentLiteralKinds, MetaKinds } from "./tokens";
export interface TextContent {
    text: string;
}
export interface Optional {
    optionalToken: Node;
}
export interface NodeEdge {
    name: string;
    isArray: boolean;
    read?(node: Node): Node;
    readArray?(node: Node): Node[];
}
export declare namespace NodeEdge {
    function create(name: string, read: (node: Node) => Node): NodeEdge;
    function createArray(name: string, readArray: (node: Node) => Node[]): NodeEdge;
}
export declare class Node<TKind extends SyntaxKind = SyntaxKind> implements TextRange {
    kind: TKind;
    id: number;
    pos: number;
    end: number;
    private _edges;
    constructor(kind: TKind);
    getEdges(): NodeEdge[];
}
export declare class StringLiteral extends Node<SyntaxKind.StringLiteral> implements TextContent {
    text: string;
    constructor(text: string);
}
export declare class Identifier extends Node<SyntaxKind.Identifier> implements TextContent {
    text: string;
    constructor(text: string);
}
export declare class LexicalSymbol<TKind extends SyntaxKind = SyntaxKind> extends Node<TKind> {
}
export declare class PrimarySymbol<TKind extends SyntaxKind = SyntaxKind> extends LexicalSymbol<TKind> {
}
export declare class OptionalSymbol<TKind extends SyntaxKind = SyntaxKind> extends PrimarySymbol<TKind> {
    questionToken: Node;
    constructor(kind: TKind, questionToken: Node);
    getChildrenCount(): 0 | 1;
    getNthChild(offset: number): Node<SyntaxKind>;
}
export declare class UnicodeCharacterLiteral extends OptionalSymbol<SyntaxKind.UnicodeCharacterLiteral> implements TextContent {
    text: string;
    constructor(text: string, questionToken: Node);
}
export declare class UnicodeCharacterRange extends LexicalSymbol<SyntaxKind.UnicodeCharacterRange> {
    left: UnicodeCharacterLiteral;
    throughKeyword: Node;
    right: UnicodeCharacterLiteral;
    constructor(left: UnicodeCharacterLiteral, throughKeyword: Node, right: UnicodeCharacterLiteral);
}
export declare class ButNotSymbol extends LexicalSymbol<SyntaxKind.ButNotSymbol> {
    left: LexicalSymbol;
    butKeyword: Node;
    notKeyword: Node;
    right: LexicalSymbol;
    constructor(left: LexicalSymbol, butKeyword: Node, notKeyword: Node, right: LexicalSymbol);
}
export declare class Terminal extends OptionalSymbol<SyntaxKind.Terminal> implements TextContent {
    text: string;
    constructor(text: string, questionToken: Node);
}
export declare class TerminalList extends Node<SyntaxKind.TerminalList> {
    terminals: Terminal[];
    constructor(terminals?: Terminal[]);
}
export declare class SymbolSet extends Node<SyntaxKind.SymbolSet> {
    openBraceToken: Node;
    elements: SymbolSpan[];
    closeBraceToken: Node;
    constructor(openBraceToken: Node, elements: SymbolSpan[], closeBraceToken: Node);
}
export declare class Assertion<TKind extends SyntaxKind = SyntaxKind> extends LexicalSymbol<TKind> {
    openBracketToken: Node;
    closeBracketToken: Node;
    constructor(kind: TKind, openBracketToken: Node, closeBracketToken: Node);
}
export declare class EmptyAssertion extends Assertion<SyntaxKind.EmptyAssertion> {
    openBracketToken: Node;
    emptyKeyword: Node;
    closeBracketToken: Node;
    constructor(openBracketToken: Node, emptyKeyword: Node, closeBracketToken: Node);
}
export declare class LookaheadAssertion extends Assertion<SyntaxKind.LookaheadAssertion> {
    openBracketToken: Node;
    lookaheadKeyword: Node;
    operatorToken: Node;
    lookahead: SymbolSpan | SymbolSet;
    closeBracketToken: Node;
    constructor(openBracketToken: Node, lookaheadKeyword: Node, operatorToken: Node, lookahead: SymbolSpan | SymbolSet, closeBracketToken: Node);
}
export declare class LexicalGoalAssertion extends Assertion<SyntaxKind.LexicalGoalAssertion> {
    openBracketToken: Node;
    lexicalKeyword: Node;
    goalKeyword: Node;
    symbol: Identifier;
    closeBracketToken: Node;
    constructor(openBracketToken: Node, lexicalKeyword: Node, goalKeyword: Node, symbol: Identifier, closeBracketToken: Node);
}
export declare class NoSymbolHereAssertion extends Assertion<SyntaxKind.NoSymbolHereAssertion> {
    openBracketToken: Node;
    noKeyword: Node;
    symbols: PrimarySymbol[];
    hereKeyword: Node;
    closeBracketToken: Node;
    constructor(openBracketToken: Node, noKeyword: Node, symbols: PrimarySymbol[], hereKeyword: Node, closeBracketToken: Node);
}
export declare class ParameterValueAssertion extends Assertion<SyntaxKind.ParameterValueAssertion> {
    openBracketToken: Node;
    operatorToken: Node;
    name: Identifier;
    closeBracketToken: Node;
    constructor(openBracketToken: Node, operatorToken: Node, name: Identifier, closeBracketToken: Node);
}
export declare class ProseAssertion extends Assertion<SyntaxKind.ProseAssertion> {
    openBracketToken: Node;
    fragments: ProseFragment[];
    closeBracketToken: Node;
    constructor(openBracketToken: Node, fragments: ProseFragment[], closeBracketToken: Node);
}
export declare class ProseFragmentLiteral<TKind extends ProseFragmentLiteralKinds = ProseFragmentLiteralKinds> extends Node<SyntaxKind> implements TextContent {
    text: string;
    constructor(kind: SyntaxKind, text: string);
}
export declare type ProseFragment = ProseFragmentLiteral | Terminal | Nonterminal;
export declare class Argument extends Node<SyntaxKind.Argument> {
    operatorToken: Node;
    name: Identifier;
    constructor(operatorToken: Node, name: Identifier);
}
export declare class ArgumentList extends Node<SyntaxKind.ArgumentList> {
    openParenToken: Node;
    elements: Argument[];
    closeParenToken: Node;
    constructor(openParenToken: Node, elements: Argument[], closeParenToken: Node);
}
export declare class Nonterminal extends OptionalSymbol<SyntaxKind.Nonterminal> {
    name: Identifier;
    argumentList: ArgumentList;
    constructor(name: Identifier, argumentList: ArgumentList, questionToken: Node);
}
export declare class Prose extends LexicalSymbol<SyntaxKind.Prose> {
    greaterThanToken: Node;
    fragments: ProseFragment[];
    constructor(greaterThanToken: Node, fragments: ProseFragment[]);
}
export declare class OneOfSymbol extends LexicalSymbol<SyntaxKind.OneOfSymbol> {
    oneKeyword: Node;
    ofKeyword: Node;
    symbols: LexicalSymbol[];
    constructor(oneKeyword: Node, ofKeyword: Node, symbols: LexicalSymbol[]);
}
export declare class SymbolSpan extends Node<SyntaxKind.SymbolSpan> {
    symbol: LexicalSymbol;
    next: SymbolSpan;
    constructor(symbol: LexicalSymbol, next: SymbolSpan);
}
export declare class LinkReference extends Node<SyntaxKind.LinkReference> {
    text: string;
    constructor(text: string);
}
export declare class RightHandSide extends Node<SyntaxKind.RightHandSide> {
    head: SymbolSpan;
    reference: LinkReference;
    constructor(head: SymbolSpan, reference: LinkReference);
}
export declare class RightHandSideList extends Node<SyntaxKind.RightHandSideList> {
    openIndentToken: Node;
    elements: RightHandSide[];
    closeIndentToken: Node;
    constructor(openIndentToken: Node, elements: RightHandSide[], closeIndentToken: Node);
}
export declare class OneOfList extends Node<SyntaxKind.OneOfList> {
    openIndentToken: Node;
    oneKeyword: Node;
    ofKeyword: Node;
    terminals: Terminal[];
    closeIndentToken: Node;
    constructor(oneKeyword: Node, ofKeyword: Node, openIndentToken: Node, terminals: Terminal[], closeIndentToken: Node);
}
export declare class Parameter extends Node<SyntaxKind.Parameter> {
    name: Identifier;
    constructor(name: Identifier);
}
export declare class ParameterList extends Node<SyntaxKind.ParameterList> {
    openParenToken: Node;
    elements: Parameter[];
    closeParenToken: Node;
    constructor(openParenToken: Node, elements: Parameter[], closeParenToken: Node);
}
export declare class SourceElement<TKind extends SyntaxKind = SyntaxKind> extends Node<TKind> {
}
export declare class Production extends SourceElement<SyntaxKind.Production> {
    name: Identifier;
    colonToken: Node;
    parameterList: ParameterList;
    body: OneOfList | RightHandSide | RightHandSideList;
    constructor(name: Identifier, parameters: ParameterList, colonToken: Node, body: OneOfList | RightHandSide | RightHandSideList);
}
export declare abstract class MetaElement<TKind extends MetaKinds = MetaKinds> extends SourceElement<TKind> {
    atToken: Node;
    constructor(kind: TKind, atToken: Node);
}
export declare class Import extends MetaElement<SyntaxKind.Import> {
    importKeyword: Node;
    path: StringLiteral;
    constructor(atToken: Node, importKeyword: Node, path: StringLiteral);
}
export declare class Define extends MetaElement<SyntaxKind.Define> {
    defineKeyword: Node;
    key: Identifier;
    valueToken: Node;
    constructor(atToken: Node, defineKeyword: Node, key: Identifier, valueToken: Node);
}
export declare class SourceFile extends Node<SyntaxKind.SourceFile> {
    filename: string;
    text: string;
    elements: SourceElement[];
    lineMap: LineMap;
    imports: string[];
    constructor(filename: string, text: string);
}
export declare function forEachChild<T>(node: Node, cbNode: (node: Node) => T): T;
export declare function edge(target: Node, name: string): void;
