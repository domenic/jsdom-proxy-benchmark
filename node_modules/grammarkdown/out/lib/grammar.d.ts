import { Host } from "./host";
import { DiagnosticMessages } from "./diagnostics";
import { CompilerOptions } from "./options";
import { Parser } from "./parser";
import { Binder, BindingTable } from "./binder";
import { Checker, Resolver } from "./checker";
import { Emitter } from "./emitter/index";
import { SourceFile } from "./nodes";
import { CancellationToken } from "prex";
export declare class Grammar {
    rootFiles: SourceFile[];
    sourceFiles: SourceFile[];
    options: CompilerOptions;
    diagnostics: DiagnosticMessages;
    readonly cancellationToken: CancellationToken;
    private static knownGrammars;
    private bindings;
    private fileMap;
    private ignoreCase;
    private innerParser;
    private innerBinder;
    private innerChecker;
    private innerEmitter;
    private host;
    private oldGrammar;
    constructor(rootNames: string[]);
    constructor(rootNames: string[], options: CompilerOptions);
    constructor(rootNames: string[], options: CompilerOptions, host: Host, oldGrammar?: Grammar, token?: CancellationToken);
    constructor(rootNames: string[], options: CompilerOptions, readFile: (file: string) => string, oldGrammar?: Grammar);
    readonly resolver: Resolver;
    protected readonly parser: Parser;
    protected readonly binder: Binder;
    protected readonly checker: Checker;
    protected readonly emitter: Emitter;
    static registerKnownGrammar(name: string, file: string): void;
    getSourceFile(file: string): SourceFile;
    /** Adds a synthetic SourceFile to the grammar. */
    addSourceFile(sourceFile: SourceFile): void;
    private parse(rootNames);
    bind(sourceFile: SourceFile): void;
    bind(): void;
    check(sourceFile?: SourceFile): void;
    resetEmitter(): void;
    emit(sourceFile?: SourceFile, writeFile?: (file: string, output: string) => void): void;
    protected createParser(options: CompilerOptions): Parser;
    protected createBinder(options: CompilerOptions, bindings: BindingTable): Binder;
    protected createChecker(options: CompilerOptions, bindings: BindingTable): Checker;
    protected createEmitter(options: CompilerOptions, resolver: Resolver): Emitter;
    protected readFile(file: string): string;
    protected writeFile(file: string, content: string): void;
    private resolveFile(file, referer?);
    private normalizeFile(file);
    private processRootFile(file);
    private processFile(file, referer?, refererPos?, refererEnd?);
    private processImports(sourceFile, refererName);
    private parseSourceFile(file);
}
