"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*!
 *  Copyright 2015 Ron Buckton (rbuckton@chronicles.org)
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
var prex_1 = require("prex");
var tokens_1 = require("./tokens");
var symbols_1 = require("./symbols");
var nodes_1 = require("./nodes");
var BindingTable = (function () {
    function BindingTable() {
        this.globals = new symbols_1.SymbolTable();
    }
    BindingTable.prototype.setParent = function (node, parent) {
        if (node && parent) {
            if (!this.parentNodes) {
                this.parentNodes = [];
            }
            this.parentNodes[node.id] = parent;
        }
    };
    BindingTable.prototype.hasParent = function (node) {
        return !!(node && this.parentNodes && node.id in this.parentNodes);
    };
    BindingTable.prototype.getParent = function (node) {
        return node && this.parentNodes && this.parentNodes[node.id];
    };
    BindingTable.prototype.getAncestor = function (node, kind) {
        for (var parent_1 = this.getParent(node); parent_1; parent_1 = this.getParent(parent_1)) {
            if (parent_1.kind === kind) {
                return parent_1;
            }
        }
        return undefined;
    };
    BindingTable.prototype.setSymbol = function (node, symbol) {
        if (node && symbol) {
            this.setSymbolForNode(node, symbol);
            this.addReferenceToSymbol(symbol, node);
        }
    };
    BindingTable.prototype.setSymbolForNode = function (node, symbol) {
        if (!this.nodeMap) {
            this.nodeMap = [];
        }
        this.nodeMap[node.id] = symbol;
    };
    BindingTable.prototype.addReferenceToSymbol = function (symbol, node) {
        if (!this.symbolReferences) {
            this.symbolReferences = [];
        }
        if (!this.symbolReferences[symbol.id]) {
            this.symbolReferences[symbol.id] = [];
        }
        if (this.symbolReferences[symbol.id].indexOf(node) === -1) {
            this.symbolReferences[symbol.id].push(node);
        }
    };
    BindingTable.prototype.hasSymbol = function (node) {
        return !!(node && this.nodeMap && node.id in this.nodeMap);
    };
    BindingTable.prototype.getSymbol = function (node) {
        if (node && this.nodeMap) {
            return this.nodeMap[node.id];
        }
        return undefined;
    };
    BindingTable.prototype.addDeclarationToSymbol = function (symbol, node) {
        if (symbol && node) {
            if (!this.symbolDeclarations) {
                this.symbolDeclarations = [];
            }
            var declarations = void 0;
            if (symbol.id in this.symbolDeclarations) {
                declarations = this.symbolDeclarations[symbol.id];
            }
            else {
                declarations = [];
                this.symbolDeclarations[symbol.id] = declarations;
            }
            declarations.push(node);
            this.setSymbolForNode(node, symbol);
            if (node.kind !== tokens_1.SyntaxKind.SourceFile) {
                this.addReferenceToSymbol(symbol, node.name);
            }
        }
    };
    BindingTable.prototype.getDeclarations = function (symbol) {
        var declarations;
        if (symbol && this.symbolDeclarations) {
            declarations = this.symbolDeclarations[symbol.id];
        }
        if (declarations) {
            return declarations;
        }
        return [];
    };
    BindingTable.prototype.getReferences = function (symbol) {
        var references;
        if (symbol && this.symbolReferences) {
            references = this.symbolReferences[symbol.id];
        }
        if (references) {
            return references;
        }
        return [];
    };
    BindingTable.prototype.getScope = function (container) {
        if (!this.symbolLocals) {
            this.symbolLocals = [];
        }
        var scope = this.symbolLocals[container.id];
        if (!scope) {
            scope = new symbols_1.SymbolTable();
            this.symbolLocals[container.id] = scope;
        }
        return scope;
    };
    BindingTable.prototype.resolveSymbol = function (location, name, meaning) {
        if (this.symbolLocals) {
            while (location) {
                if (location.kind === tokens_1.SyntaxKind.SourceFile) {
                    var result = this.globals.resolveSymbol(name, meaning);
                    if (result) {
                        return result;
                    }
                    break;
                }
                var symbol = this.getSymbol(location);
                var locals = symbol ? this.symbolLocals[symbol.id] : undefined;
                if (locals) {
                    var result = locals.resolveSymbol(name, meaning);
                    if (result) {
                        return result;
                    }
                }
                location = this.getParent(location);
            }
        }
        return undefined;
    };
    return BindingTable;
}());
exports.BindingTable = BindingTable;
var Binder = (function () {
    function Binder(bindings, cancellationToken) {
        if (cancellationToken === void 0) { cancellationToken = prex_1.CancellationToken.none; }
        this.bindings = bindings;
        this.scope = bindings.globals;
        this.cancellationToken = cancellationToken;
    }
    Binder.prototype.bindSourceFile = function (file) {
        this.cancellationToken.throwIfCancellationRequested();
        if (this.scope.resolveSymbol(file.filename, symbols_1.SymbolKind.SourceFile)) {
            // skip files that have already been bound.
            return;
        }
        var symbol = this.declareSymbol(file.filename, file, symbols_1.SymbolKind.SourceFile);
        this.bindChildren(file, symbol, this.scope);
    };
    Binder.prototype.bindProduction = function (node) {
        var symbol = this.declareSymbol(node.name.text, node, symbols_1.SymbolKind.Production);
        var scope = this.bindings.getScope(symbol);
        this.bindChildren(node, symbol, scope);
    };
    Binder.prototype.bindParameter = function (node) {
        var symbol = this.declareSymbol(node.name.text, node, symbols_1.SymbolKind.Parameter);
        this.bindChildren(node, this.parentSymbol, this.scope);
    };
    Binder.prototype.bindChildren = function (parentNode, parentSymbol, scope) {
        var _this = this;
        var saveParentNode = this.parentNode;
        var saveParentSymbol = this.parentSymbol;
        var saveScope = this.scope;
        this.parentNode = parentNode;
        this.parentSymbol = parentSymbol;
        this.scope = scope;
        nodes_1.forEachChild(parentNode, function (child) { return _this.bind(child); });
        this.scope = saveScope;
        this.parentSymbol = saveParentSymbol;
        this.parentNode = saveParentNode;
    };
    Binder.prototype.bind = function (node) {
        if (node) {
            this.bindings.setParent(node, this.parentNode);
            switch (node.kind) {
                case tokens_1.SyntaxKind.Production:
                    this.bindProduction(node);
                    break;
                case tokens_1.SyntaxKind.Parameter:
                    this.bindParameter(node);
                    break;
                default:
                    this.bindChildren(node, this.parentSymbol, this.scope);
                    break;
            }
        }
    };
    Binder.prototype.declareSymbol = function (name, declaration, kind) {
        var symbol = this.scope.declareSymbol(name, kind, this.parentSymbol);
        this.bindings.addDeclarationToSymbol(symbol, declaration);
        return symbol;
    };
    return Binder;
}());
exports.Binder = Binder;
//# sourceMappingURL=binder.js.map
