import { Range } from "./core";
import { DiagnosticMessages } from "./diagnostics";
import { CancellationToken } from "prex";
import { SourceFile } from "./nodes";
export declare class TextChange {
    range: Range;
    text: string;
}
export declare namespace TextChange {
    function create(text: string, range: Range): {
        text: string;
        range: Range;
    };
    function clone(change: TextChange): {
        text: string;
        range: Range;
    };
    function isUnchanged(change: TextChange): boolean;
    function applyChange(originalText: string, change: TextChange): string;
}
export declare class Parser {
    private scanner;
    private token;
    private sourceFile;
    private diagnostics;
    private parsingContext;
    private previousSourceFile;
    private cancellationToken;
    constructor(diagnostics: DiagnosticMessages, cancellationToken?: CancellationToken);
    parseSourceFile(filename: string, text: string): SourceFile;
    private parse(filename, text, previousSourceFile, changeRange);
    private nextToken();
    private lookahead<T>(callback);
    private tryParse<T>(callback);
    private speculate<T>(callback, isLookahead);
    private isWhitespace(skip?);
    private isEOF();
    private skipUntil(isRecoveryToken);
    private skipWhitespace(skip?);
    private readTokenValue(token);
    private readTokenText(token);
    private finishNode<TNode>(node, fullStart);
    private parseToken(token);
    private parseAnyToken(predicate);
    private parseOptional(token);
    private parseExpected(token);
    private parseExpectedOrEndOfFile(token);
    private shouldParseElement();
    private shouldSkipWhitespace();
    private shouldConsumeCloseToken();
    private parseElement();
    private recover();
    private reportDiagnostics();
    private hasCloseToken();
    private isOnCloseToken();
    private parseCloseToken();
    private hasSeparator();
    private isOnSeparator();
    private parseSeparator();
    private parseList<TNode>(listContext);
    private canBeIdentifier(kind);
    private parseIdentifier();
    private parseUnicodeCharacterLiteral(allowOptional);
    private parseProse();
    private isStartOfParameter();
    private parseParameter();
    private parseParameterListTail(openToken, parsingContext, closeTokenKind);
    private tryParseParameterList();
    private parseOneOfList();
    private parseSymbolSetTail(openBraceToken);
    private parseSymbolSpanRestOrSymbolSet();
    private parseEmptyAssertionTail(openBracketToken);
    private parseAnyLookaheadOperator();
    private parseLookaheadAssertionTail(openBracketToken);
    private parseNoSymbolHereAssertionTail(openBracketToken);
    private parseLexicalGoalAssertionTail(openBracketToken);
    private parseAnyParameterValueOperator();
    private parseParameterValueAssertionTail(openBracketToken);
    private parseInvalidAssertionTail(openBracketToken);
    private parseAssertion();
    private parseProseAssertion();
    private parseProseFragments();
    private parseProseFragmentLiteral(token);
    private parseTerminal(allowOptional);
    private isStartOfArgument();
    private parseArgument();
    private parseArgumentListTail(openToken, parsingContext, closeTokenKind);
    private tryParseArgumentList();
    private isStartOfArgumentList();
    private nextTokenIsArgument();
    private parseNonterminal(allowArgumentList, allowOptional);
    private parseOneOfSymbol();
    private parsePlaceholderSymbol();
    private parseInvalidSymbol();
    private parseUnicodeCharacterRangeOrHigher(allowOptional);
    private parseUnicodeCharacterRangeTail(left, throughKeyword);
    private parsePrimarySymbol(allowOptional);
    private parseUnarySymbol();
    private tryParseThroughOperator();
    private parseButNotSymbolTail(left, butKeyword, notKeyword);
    private parseSymbol();
    private tryParseSymbolSpan();
    private parseSymbolSpanRest();
    private parseSymbolSpan();
    private isStartOfSymbolSpan();
    private isStartOfRightHandSide();
    private parseLinkReference();
    private parseRightHandSide();
    private parseRightHandSideList();
    private parseBody();
    private parseProduction();
    private parseStringLiteral();
    private parseMetaElement();
    private parseImport(fullStart, atToken);
    private parseDefine(fullStart, atToken);
    private isStartOfSourceElement();
    private parseSourceElement();
    private parseSourceElementList();
}
