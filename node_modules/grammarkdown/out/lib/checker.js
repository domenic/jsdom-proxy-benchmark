"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*!
 *  Copyright 2015 Ron Buckton (rbuckton@chronicles.org)
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
var crypto_1 = require("crypto");
var prex_1 = require("prex");
var core_1 = require("./core");
var diagnostics_1 = require("./diagnostics");
var tokens_1 = require("./tokens");
var symbols_1 = require("./symbols");
var stringwriter_1 = require("./stringwriter");
var nodes_1 = require("./nodes");
var navigator_1 = require("./navigator");
// TODO: Check a Nonterminal as a call
// TODO: Check all Productions to ensure they have the same parameters.
var Checker = (function () {
    function Checker(bindings, diagnostics, options, cancellationToken) {
        if (cancellationToken === void 0) { cancellationToken = prex_1.CancellationToken.none; }
        this.checkedFileSet = new core_1.Dictionary();
        this.bindings = bindings;
        this.diagnostics = diagnostics;
        this.noStrictParametricProductions = options && options.noStrictParametricProductions || false;
        this.cancellationToken = cancellationToken;
    }
    Object.defineProperty(Checker.prototype, "resolver", {
        get: function () {
            if (!this.innerResolver) {
                this.innerResolver = this.createResolver(this.bindings);
            }
            return this.innerResolver;
        },
        enumerable: true,
        configurable: true
    });
    Checker.prototype.checkSourceFile = function (sourceFile) {
        if (!core_1.Dictionary.has(this.checkedFileSet, sourceFile.filename)) {
            var savedNoStrictParametricProductions = this.noStrictParametricProductions;
            this.cancellationToken.throwIfCancellationRequested();
            this.productionParametersByName = new core_1.Dictionary();
            this.sourceFile = sourceFile;
            this.diagnostics.setSourceFile(this.sourceFile);
            for (var _i = 0, _a = sourceFile.elements; _i < _a.length; _i++) {
                var element = _a[_i];
                this.preprocessSourceElement(element);
            }
            for (var _b = 0, _c = sourceFile.elements; _b < _c.length; _b++) {
                var element = _c[_b];
                this.checkSourceElement(element);
            }
            this.sourceFile = undefined;
            this.productionParametersByName = undefined;
            this.noStrictParametricProductions = savedNoStrictParametricProductions;
            core_1.Dictionary.set(this.checkedFileSet, sourceFile.filename, true);
        }
    };
    Checker.prototype.createResolver = function (bindings) {
        return new Resolver(bindings);
    };
    Checker.prototype.preprocessSourceElement = function (node) {
        switch (node.kind) {
            case tokens_1.SyntaxKind.Define:
                this.preprocessDefine(node);
                break;
        }
    };
    Checker.prototype.preprocessDefine = function (node) {
        if (!this.checkGrammarDefine(node)) {
            var nodeKey = node.key;
            var nodeKeyText = nodeKey.text;
            switch (nodeKeyText) {
                case "noStrictParametricProductions":
                    this.noStrictParametricProductions = node.valueToken.kind === tokens_1.SyntaxKind.TrueKeyword;
                    break;
                default:
                    this.diagnostics.reportNode(nodeKey, diagnostics_1.Diagnostics.Cannot_find_name_0_, nodeKeyText);
                    break;
            }
        }
    };
    Checker.prototype.checkGrammarDefine = function (node) {
        if (!node.key || !node.key.text) {
            return this.reportGrammarError(node.defineKeyword.end, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.Identifier));
        }
        if (!node.valueToken) {
            return this.reportGrammarError(node.key.end, diagnostics_1.Diagnostics._0_expected, diagnostics_1.formatList([tokens_1.SyntaxKind.TrueKeyword, tokens_1.SyntaxKind.FalseKeyword]));
        }
    };
    Checker.prototype.checkSourceElement = function (node) {
        switch (node.kind) {
            case tokens_1.SyntaxKind.Production:
                this.checkProduction(node);
                break;
            case tokens_1.SyntaxKind.InvalidSourceElement:
                this.reportInvalidSourceElement(node);
                break;
        }
    };
    Checker.prototype.checkProduction = function (node) {
        this.checkGrammarProduction(node);
        if (this.noStrictParametricProductions) {
            this.checkProductionNonStrict(node);
        }
        else {
            this.checkProductionStrict(node);
        }
        if (node.body) {
            switch (node.body.kind) {
                case tokens_1.SyntaxKind.OneOfList:
                    this.checkOneOfList(node.body);
                    break;
                case tokens_1.SyntaxKind.RightHandSideList:
                    this.checkRightHandSideList(node.body);
                    break;
                case tokens_1.SyntaxKind.RightHandSide:
                    this.checkRightHandSide(node.body);
                    break;
            }
        }
    };
    Checker.prototype.checkProductionNonStrict = function (node) {
        this.checkIdentifier(node.name);
        if (node.parameterList) {
            this.checkParameterList(node.parameterList);
        }
    };
    Checker.prototype.getProductionParametersByName = function (node) {
        var id = node.id;
        var productionParametersByName = this.productionParametersByName;
        if (core_1.Dictionary.has(productionParametersByName, id)) {
            return core_1.Dictionary.get(productionParametersByName, id);
        }
        var parameterList = node.parameterList;
        var parameters = parameterList ? parameterList.elements : undefined;
        var parameterCount = parameters ? parameters.length : 0;
        var parametersByName = new core_1.Dictionary();
        for (var i = 0; i < parameterCount; i++) {
            var parameter = parameters[i];
            var parameterName = parameter ? parameter.name : undefined;
            var parameterNameText = parameterName ? parameterName.text : undefined;
            if (parameterNameText && !core_1.Dictionary.has(parametersByName, parameterNameText)) {
                core_1.Dictionary.set(parametersByName, parameterNameText, true);
            }
        }
        core_1.Dictionary.set(productionParametersByName, id, parametersByName);
        return parametersByName;
    };
    Checker.prototype.checkProductionStrict = function (thisProduction) {
        var thisProductionName = thisProduction.name;
        var thisProductionNameText = thisProductionName.text;
        var thisProductionSymbol = this.checkIdentifier(thisProductionName);
        var thisProductionParameterList = thisProduction.parameterList;
        var thisProductionParameters = thisProductionParameterList ? thisProductionParameterList.elements : undefined;
        var thisProductionParameterCount = thisProductionParameters ? thisProductionParameters.length : 0;
        var firstProduction = this.bindings.getDeclarations(thisProductionSymbol)[0];
        if (thisProductionParameterCount) {
            this.checkParameterList(thisProduction.parameterList);
        }
        if (firstProduction === thisProduction) {
            return;
        }
        if (/test\.grammar$/.test(this.sourceFile.filename) && thisProductionNameText === "D")
            debugger;
        var thisProductionParameterNames = this.getProductionParametersByName(thisProduction);
        var firstProductionParameterList = firstProduction.parameterList;
        var firstProductionParameters = firstProductionParameterList ? firstProductionParameterList.elements : undefined;
        var firstProductionParameterCount = firstProductionParameters ? firstProductionParameters.length : 0;
        var firstProductionParameterNames = this.getProductionParametersByName(firstProduction);
        for (var i = 0; i < firstProductionParameterCount; i++) {
            var firstProductionParameter = firstProductionParameters[i];
            var firstProductionParameterName = firstProductionParameter.name;
            var firstProductionParameterNameText = firstProductionParameterName.text;
            if (!core_1.Dictionary.has(thisProductionParameterNames, firstProductionParameterNameText)) {
                this.diagnostics.reportNode(thisProductionName, diagnostics_1.Diagnostics.Production_0_is_missing_parameter_1_All_definitions_of_production_0_must_specify_the_same_formal_parameters, thisProductionNameText, firstProductionParameterNameText);
            }
        }
        for (var i = 0; i < thisProductionParameterCount; i++) {
            var thisProductionParameter = thisProductionParameters[i];
            var thisProductionParameterName = thisProductionParameter.name;
            var thisProductionParameterNameText = thisProductionParameterName.text;
            if (!core_1.Dictionary.has(firstProductionParameterNames, thisProductionParameterNameText)) {
                this.diagnostics.reportNode(firstProduction, diagnostics_1.Diagnostics.Production_0_is_missing_parameter_1_All_definitions_of_production_0_must_specify_the_same_formal_parameters, thisProductionNameText, thisProductionParameterNameText);
            }
        }
    };
    Checker.prototype.checkGrammarProduction = function (node) {
        var pos = node.name.end;
        if (node.parameterList) {
            pos = node.parameterList.end;
        }
        if (!node.colonToken) {
            return this.reportGrammarError(pos, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.ColonToken));
        }
        pos += node.colonToken.end;
        if (!node.body) {
            return this.reportGrammarError(pos, diagnostics_1.Diagnostics._0_expected, diagnostics_1.formatList([
                tokens_1.SyntaxKind.OneOfList,
                tokens_1.SyntaxKind.RightHandSide,
            ]));
        }
        switch (node.body.kind) {
            case tokens_1.SyntaxKind.OneOfList:
            case tokens_1.SyntaxKind.RightHandSide:
            case tokens_1.SyntaxKind.RightHandSideList:
                break;
            default:
                return this.reportGrammarError(pos, diagnostics_1.Diagnostics._0_expected, diagnostics_1.formatList([
                    tokens_1.SyntaxKind.OneOfList,
                    tokens_1.SyntaxKind.RightHandSide,
                ]));
        }
        return false;
    };
    Checker.prototype.checkParameterList = function (node) {
        this.checkGrammarParameterList(node);
        for (var _i = 0, _a = node.elements; _i < _a.length; _i++) {
            var element = _a[_i];
            this.checkParameter(element);
        }
    };
    Checker.prototype.checkGrammarParameterList = function (node) {
        if (!node.openParenToken) {
            return this.reportGrammarError(node.pos, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.OpenBracketToken));
        }
        if (node.openParenToken.kind === tokens_1.SyntaxKind.OpenParenToken) {
            return this.reportGrammarErrorForNode(node.openParenToken, diagnostics_1.Diagnostics.Obsolete_0_, "Support for using parenthesis to enclose production parameter lists is deprecated and may be removed in a future update. Please switch to bracket's ('[', ']') when enclosing production parameter lists.");
        }
        if (!node.elements) {
            return this.reportGrammarError(node.pos, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.Identifier));
        }
        if (!node.closeParenToken) {
            return this.reportGrammarError(node.pos, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.CloseBracketToken));
        }
    };
    Checker.prototype.checkParameter = function (node) {
        this.checkIdentifier(node.name);
    };
    Checker.prototype.checkOneOfList = function (node) {
        this.checkGrammarOneOfList(node);
        if (node.terminals) {
            var terminalSet = new core_1.Dictionary();
            for (var _i = 0, _a = node.terminals; _i < _a.length; _i++) {
                var terminal = _a[_i];
                var text = terminal.text;
                if (core_1.Dictionary.has(terminalSet, text)) {
                    this.diagnostics.reportNode(terminal, diagnostics_1.Diagnostics.Duplicate_terminal_0_, text);
                }
                else {
                    core_1.Dictionary.set(terminalSet, text, true);
                    this.checkTerminal(terminal);
                }
            }
        }
    };
    Checker.prototype.checkGrammarOneOfList = function (node) {
        if (!node.oneKeyword) {
            return this.reportGrammarError(node.pos, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.OneKeyword));
        }
        if (!node.ofKeyword) {
            return this.reportGrammarError(node.oneKeyword.end, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.OfKeyword));
        }
        if (!node.terminals) {
            return this.reportGrammarError(node.ofKeyword.end, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.Terminal));
        }
        if (node.openIndentToken && !node.closeIndentToken) {
            return this.reportGrammarError(node.end, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.DedentToken));
        }
        return false;
    };
    Checker.prototype.checkRightHandSideList = function (node) {
        this.checkGrammarRightHandSideList(node);
        if (node.elements) {
            for (var _i = 0, _a = node.elements; _i < _a.length; _i++) {
                var element = _a[_i];
                this.checkRightHandSide(element);
            }
        }
    };
    Checker.prototype.checkGrammarRightHandSideList = function (node) {
        if (!node.openIndentToken) {
            return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.IndentToken));
        }
        if (!node.elements || node.elements.length === 0) {
            return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics._0_expected, diagnostics_1.formatList([
                tokens_1.SyntaxKind.Terminal,
                tokens_1.SyntaxKind.Identifier,
                tokens_1.SyntaxKind.OpenBracketToken
            ]));
        }
        if (!node.closeIndentToken) {
            return this.reportGrammarError(node.end, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.DedentToken));
        }
        return false;
    };
    Checker.prototype.checkRightHandSide = function (node) {
        this.checkSymbolSpan(node.head);
        if (node.reference) {
            this.checkLinkReference(node.reference);
        }
    };
    Checker.prototype.checkLinkReference = function (node) {
        this.checkGrammarLinkReference(node);
    };
    Checker.prototype.checkGrammarLinkReference = function (node) {
        if (!node.text) {
            return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics._0_expected, "string");
        }
        return false;
    };
    Checker.prototype.checkSymbolSpan = function (node) {
        this.checkGrammarSymbolSpan(node);
        this.checkSymbolSpanOrHigher(node.symbol);
        if (node.next) {
            this.checkSymbolSpanRest(node.next);
        }
    };
    Checker.prototype.checkGrammarSymbolSpan = function (node) {
        if (!node.symbol) {
            return this.reportGrammarError(node.pos, diagnostics_1.Diagnostics._0_expected, diagnostics_1.formatList([
                tokens_1.SyntaxKind.UnicodeCharacterLiteral,
                tokens_1.SyntaxKind.Terminal,
                tokens_1.SyntaxKind.Identifier,
                tokens_1.SyntaxKind.OpenBracketToken,
                tokens_1.SyntaxKind.Prose
            ]));
        }
        if (node.next) {
            if (node.symbol.kind === tokens_1.SyntaxKind.Prose) {
                return this.reportGrammarError(node.symbol.end, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.LineTerminatorToken));
            }
        }
        return false;
    };
    Checker.prototype.checkSymbolSpanOrHigher = function (node) {
        if (node.kind === tokens_1.SyntaxKind.Prose) {
            this.checkProse(node);
            return;
        }
        this.checkSymbolOrHigher(node);
    };
    Checker.prototype.checkProse = function (node) {
        for (var _i = 0, _a = node.fragments; _i < _a.length; _i++) {
            var fragment = _a[_i];
            this.checkProseFragment(fragment);
        }
    };
    Checker.prototype.checkSymbolSpanRest = function (node) {
        this.checkGrammarSymbolSpanRest(node);
        this.checkSymbolOrHigher(node.symbol);
        if (node.next) {
            this.checkSymbolSpanRest(node.next);
        }
    };
    Checker.prototype.checkGrammarSymbolSpanRest = function (node) {
        if (!node.symbol) {
            return this.reportGrammarError(node.pos, diagnostics_1.Diagnostics._0_expected, diagnostics_1.formatList([
                tokens_1.SyntaxKind.UnicodeCharacterLiteral,
                tokens_1.SyntaxKind.Terminal,
                tokens_1.SyntaxKind.Identifier,
                tokens_1.SyntaxKind.OpenBracketToken,
                tokens_1.SyntaxKind.LineTerminatorToken
            ]));
        }
        if (node.symbol.kind === tokens_1.SyntaxKind.Prose) {
            return this.reportGrammarError(node.symbol.pos, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.LineTerminatorToken));
        }
        if (node.next && node.next.symbol.kind === tokens_1.SyntaxKind.Prose) {
            return this.reportGrammarError(node.next.pos, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.LineTerminatorToken));
        }
        return false;
    };
    Checker.prototype.checkSymbolOrHigher = function (node) {
        if (isAssertion(node)) {
            this.checkAssertion(node);
            return;
        }
        this.checkButNotSymbolOrHigher(node);
    };
    Checker.prototype.checkAssertion = function (node) {
        switch (node.kind) {
            case tokens_1.SyntaxKind.EmptyAssertion:
                this.checkEmptyAssertion(node);
                break;
            case tokens_1.SyntaxKind.LookaheadAssertion:
                this.checkLookaheadAssertion(node);
                break;
            case tokens_1.SyntaxKind.LexicalGoalAssertion:
                this.checkLexicalGoalAssertion(node);
                break;
            case tokens_1.SyntaxKind.NoSymbolHereAssertion:
                this.checkNoSymbolHereAssertion(node);
                break;
            case tokens_1.SyntaxKind.ParameterValueAssertion:
                this.checkParameterValueAssertion(node);
                break;
            case tokens_1.SyntaxKind.ProseAssertion:
                this.checkProseAssertion(node);
                break;
            case tokens_1.SyntaxKind.InvalidAssertion:
                this.reportInvalidAssertion(node);
                break;
        }
    };
    Checker.prototype.checkGrammarAssertionHead = function (node) {
        if (!node.openBracketToken) {
            return this.reportGrammarError(node.pos, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.OpenBracketToken));
        }
        return false;
    };
    Checker.prototype.checkGrammarAssertionTail = function (node) {
        if (!node.closeBracketToken) {
            return this.reportGrammarError(node.end, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.CloseBracketToken));
        }
        return false;
    };
    Checker.prototype.checkEmptyAssertion = function (node) {
        this.checkGrammarAssertionHead(node) || this.checkGrammarEmptyAssertion(node) || this.checkGrammarAssertionTail(node);
    };
    Checker.prototype.checkGrammarEmptyAssertion = function (node) {
        if (!node.emptyKeyword) {
            return this.reportGrammarError(node.openBracketToken.end, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.EmptyKeyword, /*quoted*/ true));
        }
    };
    Checker.prototype.checkLookaheadAssertion = function (node) {
        this.checkGrammarAssertionHead(node) || this.checkGrammarLookaheadAssertion(node) || this.checkGrammarAssertionTail(node);
        if (node.lookahead) {
            if (node.lookahead.kind === tokens_1.SyntaxKind.SymbolSet) {
                this.checkSymbolSet(node.lookahead);
                return;
            }
            this.checkSymbolSpanRest(node.lookahead);
        }
    };
    Checker.prototype.checkGrammarLookaheadAssertion = function (node) {
        if (!node.lookaheadKeyword) {
            return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.LookaheadKeyword, /*quoted*/ true));
        }
        if (!node.operatorToken) {
            return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics._0_expected, diagnostics_1.formatList([
                tokens_1.SyntaxKind.EqualsToken,
                tokens_1.SyntaxKind.EqualsEqualsToken,
                tokens_1.SyntaxKind.ExclamationEqualsToken,
                tokens_1.SyntaxKind.LessThanMinusToken,
                tokens_1.SyntaxKind.LessThanExclamationToken
            ]));
        }
        switch (node.operatorToken.kind) {
            case tokens_1.SyntaxKind.EqualsToken:
            case tokens_1.SyntaxKind.EqualsEqualsToken:
            case tokens_1.SyntaxKind.ExclamationEqualsToken:
            case tokens_1.SyntaxKind.NotEqualToToken:
            case tokens_1.SyntaxKind.LessThanMinusToken:
            case tokens_1.SyntaxKind.ElementOfToken:
            case tokens_1.SyntaxKind.LessThanExclamationToken:
            case tokens_1.SyntaxKind.NotAnElementOfToken:
                break;
            default:
                return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics._0_expected, diagnostics_1.formatList([
                    tokens_1.SyntaxKind.EqualsToken,
                    tokens_1.SyntaxKind.EqualsEqualsToken,
                    tokens_1.SyntaxKind.ExclamationEqualsToken,
                    tokens_1.SyntaxKind.LessThanMinusToken,
                    tokens_1.SyntaxKind.LessThanExclamationToken
                ]));
        }
        if (!node.lookahead) {
            switch (node.operatorToken.kind) {
                case tokens_1.SyntaxKind.EqualsToken:
                case tokens_1.SyntaxKind.EqualsEqualsToken:
                case tokens_1.SyntaxKind.ExclamationEqualsToken:
                case tokens_1.SyntaxKind.NotEqualToToken:
                    return this.reportGrammarError(node.operatorToken.end, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.Terminal));
                case tokens_1.SyntaxKind.LessThanMinusToken:
                case tokens_1.SyntaxKind.ElementOfToken:
                case tokens_1.SyntaxKind.LessThanExclamationToken:
                case tokens_1.SyntaxKind.NotAnElementOfToken:
                    return this.reportGrammarError(node.operatorToken.end, diagnostics_1.Diagnostics._0_expected, diagnostics_1.formatList([tokens_1.SyntaxKind.OpenBraceToken, tokens_1.SyntaxKind.Nonterminal]));
            }
        }
        switch (node.operatorToken.kind) {
            case tokens_1.SyntaxKind.EqualsToken:
            case tokens_1.SyntaxKind.EqualsEqualsToken:
            case tokens_1.SyntaxKind.ExclamationEqualsToken:
            case tokens_1.SyntaxKind.NotEqualToToken:
                if (!isTerminal(node.lookahead)) {
                    return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics._0_expected, diagnostics_1.formatList([
                        tokens_1.SyntaxKind.Terminal,
                        tokens_1.SyntaxKind.UnicodeCharacterLiteral
                    ]));
                }
                break;
            case tokens_1.SyntaxKind.LessThanMinusToken:
            case tokens_1.SyntaxKind.ElementOfToken:
            case tokens_1.SyntaxKind.LessThanExclamationToken:
            case tokens_1.SyntaxKind.NotAnElementOfToken:
                if (!isNonterminalOrSymbolSet(node.lookahead)) {
                    return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics._0_expected, diagnostics_1.formatList([
                        tokens_1.SyntaxKind.OpenBraceToken,
                        tokens_1.SyntaxKind.Nonterminal
                    ]));
                }
                break;
        }
        return false;
        function isTerminal(node) {
            if (node.kind !== tokens_1.SyntaxKind.SymbolSpan)
                return false;
            switch (node.symbol.kind) {
                case tokens_1.SyntaxKind.Terminal:
                case tokens_1.SyntaxKind.UnicodeCharacterLiteral:
                    return true;
            }
            return false;
        }
        function isNonterminalOrSymbolSet(node) {
            return node.kind === tokens_1.SyntaxKind.SymbolSpan
                ? node.symbol.kind === tokens_1.SyntaxKind.Nonterminal
                : node.kind === tokens_1.SyntaxKind.SymbolSet;
        }
    };
    Checker.prototype.checkSymbolSet = function (node) {
        this.checkGrammarSymbolSet(node);
        if (node.elements) {
            for (var _i = 0, _a = node.elements; _i < _a.length; _i++) {
                var element = _a[_i];
                this.checkSymbolSpanRest(element);
            }
        }
    };
    Checker.prototype.checkGrammarSymbolSet = function (node) {
        if (!node.openBraceToken) {
            return this.reportGrammarError(node.pos, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.OpenBraceToken));
        }
        if (!node.elements) {
            return this.reportGrammarError(node.openBraceToken.end, diagnostics_1.Diagnostics._0_expected, diagnostics_1.formatList([
                tokens_1.SyntaxKind.Identifier,
                tokens_1.SyntaxKind.Terminal,
                tokens_1.SyntaxKind.UnicodeCharacterLiteral
            ]));
        }
        if (!node.closeBraceToken) {
            return this.reportGrammarError(node.end, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.CloseBraceToken));
        }
        return false;
    };
    Checker.prototype.checkLexicalGoalAssertion = function (node) {
        this.checkGrammarAssertionHead(node) || this.checkGrammarLexicalGoalAssertion(node) || this.checkGrammarAssertionTail(node);
        if (node.symbol) {
            this.checkIdentifier(node.symbol);
        }
    };
    Checker.prototype.checkGrammarLexicalGoalAssertion = function (node) {
        if (!node.lexicalKeyword) {
            return this.reportGrammarError(node.pos, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.LexicalKeyword));
        }
        if (!node.goalKeyword) {
            return this.reportGrammarError(node.lexicalKeyword.end, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.GoalKeyword));
        }
        if (!node.symbol) {
            return this.reportGrammarError(node.end, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.Identifier));
        }
        return false;
    };
    Checker.prototype.checkNoSymbolHereAssertion = function (node) {
        this.checkGrammarAssertionHead(node) || this.checkGrammarNoSymbolHereAssertion(node) || this.checkGrammarAssertionTail(node);
        if (node.symbols) {
            for (var _i = 0, _a = node.symbols; _i < _a.length; _i++) {
                var symbol = _a[_i];
                this.checkPrimarySymbol(symbol);
            }
        }
    };
    Checker.prototype.checkGrammarNoSymbolHereAssertion = function (node) {
        if (!node.noKeyword) {
            return this.reportGrammarError(node.pos, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.NoKeyword));
        }
        if (!node.symbols || node.symbols.length <= 0) {
            return this.reportGrammarError(node.noKeyword.end, diagnostics_1.Diagnostics._0_expected, diagnostics_1.formatList([
                tokens_1.SyntaxKind.Identifier,
                tokens_1.SyntaxKind.Terminal,
                tokens_1.SyntaxKind.UnicodeCharacterLiteral
            ]));
        }
        if (!node.hereKeyword) {
            return this.reportGrammarError(node.end, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.HereKeyword));
        }
        return false;
    };
    Checker.prototype.checkParameterValueAssertion = function (node) {
        this.checkGrammarAssertionHead(node) || this.checkGrammarParameterValueAssertion(node) || this.checkGrammarAssertionTail(node);
        if (node.name) {
            this.checkIdentifier(node.name);
        }
    };
    Checker.prototype.checkGrammarParameterValueAssertion = function (node) {
        if (node.operatorToken) {
            switch (node.operatorToken.kind) {
                case tokens_1.SyntaxKind.TildeToken:
                case tokens_1.SyntaxKind.PlusToken:
                    break;
                default:
                    return this.reportGrammarErrorForNode(node.operatorToken, diagnostics_1.Diagnostics.Unexpected_token_0_, tokens_1.tokenToString(node.operatorToken.kind));
            }
        }
        return false;
    };
    Checker.prototype.checkProseAssertion = function (node) {
        this.checkGrammarProseAssertionHead(node) || this.checkGrammarAssertionTail(node);
        for (var _i = 0, _a = node.fragments; _i < _a.length; _i++) {
            var fragment = _a[_i];
            this.checkProseFragment(fragment);
        }
    };
    Checker.prototype.checkGrammarProseAssertionHead = function (node) {
        if (!node.openBracketToken) {
            return this.reportGrammarError(node.pos, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.OpenBracketGreaterThanToken));
        }
        return false;
    };
    Checker.prototype.checkProseFragment = function (fragment) {
        switch (fragment.kind) {
            case tokens_1.SyntaxKind.Nonterminal:
                this.checkNonterminal(fragment, /*allowOptional*/ false);
                break;
            case tokens_1.SyntaxKind.Terminal:
                this.checkTerminal(fragment, /*allowOptional*/ false);
                break;
            case tokens_1.SyntaxKind.ProseFull:
            case tokens_1.SyntaxKind.ProseHead:
            case tokens_1.SyntaxKind.ProseMiddle:
            case tokens_1.SyntaxKind.ProseTail:
                this.checkProseFragmentLiteral(fragment);
                break;
        }
    };
    Checker.prototype.checkProseFragmentLiteral = function (node) {
        if (typeof node.text !== "string") {
            this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.UnicodeCharacterLiteral));
        }
    };
    Checker.prototype.reportInvalidAssertion = function (node) {
        if (this.checkGrammarAssertionHead(node)) {
            return;
        }
        this.reportGrammarError(node.openBracketToken.end, diagnostics_1.Diagnostics._0_expected, diagnostics_1.formatList([
            tokens_1.SyntaxKind.LookaheadKeyword,
            tokens_1.SyntaxKind.LexicalKeyword,
            tokens_1.SyntaxKind.NoKeyword,
            tokens_1.SyntaxKind.TildeToken,
            tokens_1.SyntaxKind.PlusToken
        ]));
    };
    Checker.prototype.checkButNotSymbolOrHigher = function (node) {
        if (node.kind === tokens_1.SyntaxKind.ButNotSymbol) {
            this.checkButNotSymbol(node);
            return;
        }
        this.checkUnarySymbolOrHigher(node);
    };
    Checker.prototype.checkButNotSymbol = function (node) {
        this.checkGrammarButNotSymbol(node);
        this.checkUnarySymbolOrHigher(node.left);
        this.checkUnarySymbolOrHigher(node.right);
    };
    Checker.prototype.checkGrammarButNotSymbol = function (node) {
        if (!node.butKeyword) {
            return this.reportGrammarErrorForNode(node.notKeyword || node.right, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.ButKeyword));
        }
        if (!node.notKeyword) {
            return this.reportGrammarErrorForNode(node.right, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.NotKeyword));
        }
        if (!node.right) {
            return this.reportGrammarError(node.end, diagnostics_1.Diagnostics._0_expected, diagnostics_1.formatList([
                tokens_1.SyntaxKind.Identifier,
                tokens_1.SyntaxKind.Terminal,
                tokens_1.SyntaxKind.UnicodeCharacterLiteral,
                tokens_1.SyntaxKind.OneKeyword
            ]));
        }
        return false;
    };
    Checker.prototype.checkUnarySymbolOrHigher = function (node) {
        if (node.kind === tokens_1.SyntaxKind.OneOfSymbol) {
            this.checkOneOfSymbol(node);
            return;
        }
        this.checkOptionalSymbolOrHigher(node);
    };
    Checker.prototype.checkOneOfSymbol = function (node) {
        this.checkGrammarOneOfSymbol(node);
        if (node.symbols) {
            for (var _i = 0, _a = node.symbols; _i < _a.length; _i++) {
                var symbol = _a[_i];
                this.checkPrimarySymbol(symbol);
            }
        }
    };
    Checker.prototype.checkGrammarOneOfSymbol = function (node) {
        if (!node.oneKeyword) {
            return this.reportGrammarError(node.pos, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.OneKeyword));
        }
        if (!node.ofKeyword) {
            return this.reportGrammarError(node.oneKeyword.end, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.OfKeyword));
        }
        if (!node.symbols || node.symbols.length <= 0) {
            return this.reportGrammarError(node.end, diagnostics_1.Diagnostics._0_expected, diagnostics_1.formatList([
                tokens_1.SyntaxKind.Identifier,
                tokens_1.SyntaxKind.Terminal,
                tokens_1.SyntaxKind.UnicodeCharacterLiteral
            ]));
        }
        return false;
    };
    Checker.prototype.checkOptionalSymbolOrHigher = function (node) {
        this.checkPrimarySymbol(node, true);
    };
    Checker.prototype.checkPrimarySymbol = function (node, allowOptional) {
        switch (node.kind) {
            case tokens_1.SyntaxKind.Terminal:
                this.checkTerminal(node, allowOptional);
                break;
            case tokens_1.SyntaxKind.UnicodeCharacterLiteral:
                this.checkUnicodeCharacterLiteral(node, allowOptional);
                break;
            case tokens_1.SyntaxKind.UnicodeCharacterRange:
                this.checkUnicodeCharacterRange(node);
                break;
            case tokens_1.SyntaxKind.Nonterminal:
                this.checkNonterminal(node, allowOptional);
                break;
            case tokens_1.SyntaxKind.AtToken:
                this.checkPlaceholder(node);
                break;
            default:
                this.reportInvalidSymbol(node);
                break;
        }
    };
    Checker.prototype.checkGrammarOptionalSymbol = function (node, allowOptional) {
        if (node.questionToken) {
            if (!allowOptional || node.questionToken.kind !== tokens_1.SyntaxKind.QuestionToken) {
                return this.reportGrammarErrorForNode(node.questionToken, diagnostics_1.Diagnostics.Unexpected_token_0_, tokens_1.tokenToString(node.questionToken.kind));
            }
        }
        return false;
    };
    Checker.prototype.checkTerminal = function (node, allowOptional) {
        this.checkGrammarOptionalSymbol(node, allowOptional) || this.checkGrammarTerminal(node);
    };
    Checker.prototype.checkGrammarTerminal = function (node) {
        if (typeof node.text !== "string" || node.text.length === 0) {
            return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.Terminal));
        }
        return false;
    };
    Checker.prototype.checkGrammarUnicodeCharacterRange = function (node) {
        if (!node.left) {
            return this.reportGrammarErrorForNode(node.throughKeyword || node.right || node, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.UnicodeCharacterLiteral));
        }
        if (!node.throughKeyword) {
            return this.reportGrammarErrorForNode(node.right || node, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.ThroughKeyword));
        }
        if (!node.right) {
            return this.reportGrammarError(node.end, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.UnicodeCharacterLiteral));
        }
        return false;
    };
    Checker.prototype.checkUnicodeCharacterRange = function (node) {
        this.checkGrammarUnicodeCharacterRange(node);
        this.checkUnicodeCharacterLiteral(node.left);
        this.checkUnicodeCharacterLiteral(node.right);
    };
    Checker.prototype.checkUnicodeCharacterLiteral = function (node, allowOptional) {
        this.checkGrammarOptionalSymbol(node, allowOptional) || this.checkGrammarUnicodeCharacterLiteral(node);
    };
    Checker.prototype.checkGrammarUnicodeCharacterLiteral = function (node) {
        if (typeof node.text !== "string" || node.text.length === 0) {
            return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.UnicodeCharacterLiteral));
        }
        return false;
    };
    Checker.prototype.checkPlaceholder = function (node) {
    };
    Checker.prototype.checkNonterminal = function (node, allowOptional) {
        this.checkGrammarOptionalSymbol(node, allowOptional);
        if (this.noStrictParametricProductions) {
            this.checkNonterminalNonStrict(node);
        }
        else {
            this.checkNonterminalStrict(node);
        }
    };
    Checker.prototype.checkNonterminalNonStrict = function (node) {
        this.checkIdentifier(node.name);
        if (node.argumentList) {
            this.checkArgumentList(node.argumentList);
        }
    };
    Checker.prototype.checkNonterminalStrict = function (node) {
        var nonterminalName = node.name;
        var productionSymbol = this.checkIdentifier(nonterminalName);
        if (productionSymbol) {
            var production = this.bindings.getDeclarations(productionSymbol)[0];
            var parameterCount = production.parameterList ? production.parameterList.elements.length : 0;
            var argumentCount = node.argumentList ? node.argumentList.elements.length : 0;
            var nameSet = new core_1.Dictionary();
            // Check each argument has a matching parameter.
            for (var i = 0; i < argumentCount; i++) {
                var argument = node.argumentList.elements[i];
                var argumentName = argument.name;
                var argumentNameText = argumentName.text;
                if (core_1.Dictionary.has(nameSet, argumentNameText)) {
                    this.diagnostics.reportNode(argumentName, diagnostics_1.Diagnostics.Argument_0_cannot_be_specified_multiple_times, argumentNameText);
                }
                else {
                    core_1.Dictionary.set(nameSet, argumentNameText, true);
                    var parameterSymbol = this.resolveSymbol(production, argumentNameText, symbols_1.SymbolKind.Parameter);
                    if (!parameterSymbol) {
                        this.diagnostics.reportNode(argumentName, diagnostics_1.Diagnostics.Production_0_does_not_have_a_parameter_named_1_, productionSymbol.name, argumentNameText);
                    }
                }
            }
            // Check each parameter has a matching argument.
            for (var i = 0; i < parameterCount; i++) {
                var parameter = production.parameterList.elements[i];
                var parameterName = parameter.name;
                var parameterNameText = parameterName.text;
                if (!core_1.Dictionary.has(nameSet, parameterNameText)) {
                    this.diagnostics.reportNode(nonterminalName, diagnostics_1.Diagnostics.There_is_no_argument_given_for_parameter_0_, parameterNameText);
                }
            }
        }
        if (node.argumentList) {
            this.checkArgumentList(node.argumentList);
        }
    };
    Checker.prototype.checkArgumentList = function (node) {
        this.checkGrammarArgumentList(node);
        if (node.elements) {
            for (var _i = 0, _a = node.elements; _i < _a.length; _i++) {
                var element = _a[_i];
                this.checkArgument(element);
            }
        }
    };
    Checker.prototype.checkGrammarArgumentList = function (node) {
        if (!node.openParenToken) {
            return this.reportGrammarError(node.pos, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.OpenBracketToken));
        }
        if (node.openParenToken.kind === tokens_1.SyntaxKind.OpenParenToken) {
            return this.reportGrammarErrorForNode(node.openParenToken, diagnostics_1.Diagnostics.Obsolete_0_, "Support for using parenthesis to enclose an argument list is deprecated and may be removed in a future update. Please switch to bracket's ('[', ']') when enclosing argument lists.");
        }
        if (!node.elements) {
            return this.reportGrammarError(node.pos, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.Identifier));
        }
        if (!node.closeParenToken) {
            return this.reportGrammarError(node.pos, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.CloseBracketToken));
        }
        return false;
    };
    Checker.prototype.checkArgument = function (node) {
        this.checkGrammarArgument(node);
        this.checkIdentifier(node.name);
    };
    Checker.prototype.checkGrammarArgument = function (node) {
        if (node.operatorToken
            && node.operatorToken.kind !== tokens_1.SyntaxKind.QuestionToken
            && node.operatorToken.kind !== tokens_1.SyntaxKind.PlusToken
            && node.operatorToken.kind !== tokens_1.SyntaxKind.TildeToken) {
            return this.reportGrammarErrorForNode(node.operatorToken, diagnostics_1.Diagnostics.Unexpected_token_0_, tokens_1.tokenToString(node.operatorToken.kind));
        }
        if (!node.operatorToken && !this.noStrictParametricProductions) {
            return this.reportGrammarError(node.pos, diagnostics_1.Diagnostics._0_expected, diagnostics_1.formatList([tokens_1.SyntaxKind.QuestionToken, tokens_1.SyntaxKind.PlusToken, tokens_1.SyntaxKind.TildeToken]));
        }
        return false;
    };
    Checker.prototype.reportInvalidSymbol = function (node) {
        this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics._0_expected, diagnostics_1.formatList([
            tokens_1.SyntaxKind.Terminal,
            tokens_1.SyntaxKind.Identifier,
            tokens_1.SyntaxKind.OpenBracketToken,
            tokens_1.SyntaxKind.OneKeyword
        ]));
    };
    Checker.prototype.checkIdentifier = function (node) {
        this.checkGrammarIdentifier(node);
        if (node.text) {
            var parent_1 = this.bindings.getParent(node);
            if (parent_1) {
                var symbol = void 0;
                switch (parent_1.kind) {
                    case tokens_1.SyntaxKind.Parameter:
                        symbol = this.resolveSymbol(node, node.text, symbols_1.SymbolKind.Parameter);
                        var declarationSymbol = this.bindings.getSymbol(parent_1);
                        if (declarationSymbol !== symbol) {
                            this.diagnostics.reportNode(node, diagnostics_1.Diagnostics.Duplicate_identifier_0_, node.text);
                        }
                        return symbol;
                    case tokens_1.SyntaxKind.Production:
                        return this.bindings.getSymbol(parent_1);
                    case tokens_1.SyntaxKind.LookaheadAssertion:
                    case tokens_1.SyntaxKind.Nonterminal:
                        symbol = this.resolveSymbol(node, node.text, symbols_1.SymbolKind.Production, diagnostics_1.Diagnostics.Cannot_find_name_0_);
                        break;
                    case tokens_1.SyntaxKind.Argument:
                        var argument = parent_1;
                        if (argument.operatorToken && argument.operatorToken.kind === tokens_1.SyntaxKind.QuestionToken) {
                            symbol = this.resolveSymbol(node, node.text, symbols_1.SymbolKind.Parameter);
                            if (!symbol) {
                                var production = this.bindings.getAncestor(argument, tokens_1.SyntaxKind.Production);
                                this.diagnostics.reportNode(node, diagnostics_1.Diagnostics.Production_0_does_not_have_a_parameter_named_1_, production.name.text, node.text);
                            }
                        }
                        else {
                            // get the symbol of the parameter of the target production
                            var nonterminal = this.bindings.getAncestor(parent_1, tokens_1.SyntaxKind.Nonterminal);
                            if (nonterminal && nonterminal.name && nonterminal.name.text) {
                                var productionSymbol = this.resolveSymbol(node, nonterminal.name.text, symbols_1.SymbolKind.Production);
                                if (productionSymbol) {
                                    var production = this.bindings.getDeclarations(productionSymbol)[0];
                                    symbol = this.resolveSymbol(production, node.text, symbols_1.SymbolKind.Parameter);
                                    if (!symbol) {
                                        this.diagnostics.reportNode(node, diagnostics_1.Diagnostics.Production_0_does_not_have_a_parameter_named_1_, production.name.text, node.text);
                                    }
                                }
                            }
                        }
                        break;
                }
                this.bindings.setSymbol(node, symbol);
                return symbol;
            }
        }
        return undefined;
    };
    Checker.prototype.checkGrammarIdentifier = function (node) {
        if (typeof node.text === "undefined" || node.text.length <= 0) {
            return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.Identifier));
        }
        return false;
    };
    Checker.prototype.reportInvalidSourceElement = function (node) {
        this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics._0_expected, diagnostics_1.formatList([
            tokens_1.SyntaxKind.Production
        ]));
    };
    Checker.prototype.resolveSymbol = function (location, name, meaning, diagnosticMessage) {
        var result = this.bindings.resolveSymbol(location, name, meaning);
        if (!result && diagnosticMessage) {
            this.diagnostics.reportNode(location, diagnosticMessage, name);
        }
        return result;
    };
    Checker.prototype.reportGrammarError = function (pos, diagnosticMessage, arg0, arg1, arg2) {
        this.diagnostics.report(pos, diagnosticMessage, arg0, arg1, arg2);
        return true;
    };
    Checker.prototype.reportGrammarErrorForNode = function (location, diagnosticMessage, arg0, arg1, arg2) {
        this.diagnostics.reportNode(location, diagnosticMessage, arg0, arg1, arg2);
        return true;
    };
    return Checker;
}());
exports.Checker = Checker;
var Resolver = (function () {
    function Resolver(bindings) {
        this.bindings = bindings;
    }
    Resolver.prototype.getParent = function (node) {
        return this.bindings.getParent(node);
    };
    Resolver.prototype.createNavigator = function (node) {
        if (node.kind === tokens_1.SyntaxKind.SourceFile) {
            return new navigator_1.NodeNavigator(node);
        }
        else {
            var parent_2 = this.bindings.getParent(node);
            if (parent_2) {
                var navigator_2 = this.createNavigator(parent_2);
                if (navigator_2 && navigator_2.moveToFirstChild(function (child) { return child === node; })) {
                    return navigator_2;
                }
            }
        }
        return undefined;
    };
    Resolver.prototype.getSourceFileOfNode = function (node) {
        return this.bindings.getAncestor(node, tokens_1.SyntaxKind.SourceFile);
    };
    Resolver.prototype.getDeclarations = function (node) {
        var parent = this.bindings.getParent(node);
        var symbol = this.bindings.getSymbol(node);
        if (!symbol) {
            symbol = this.bindings.resolveSymbol(node, node.text, getSymbolMeaning(parent));
        }
        if (symbol) {
            return this.bindings.getDeclarations(symbol);
        }
        return [];
    };
    Resolver.prototype.getReferences = function (node) {
        var symbol = this.bindings.getParent(node).kind === tokens_1.SyntaxKind.Parameter
            ? this.bindings.resolveSymbol(node, node.text, symbols_1.SymbolKind.Parameter)
            : this.bindings.resolveSymbol(node, node.text, symbols_1.SymbolKind.Production);
        if (symbol) {
            return this.bindings.getReferences(symbol);
        }
        return [];
    };
    Resolver.prototype.getProductionLinkId = function (node) {
        var symbol = this.bindings.resolveSymbol(node, node.text, symbols_1.SymbolKind.Production);
        if (symbol) {
            return symbol.name;
        }
        return undefined;
    };
    Resolver.prototype.getRightHandSideLinkId = function (node, includePrefix) {
        var linkId;
        if (node.reference && node.reference.text) {
            linkId = node.reference.text.replace(/[^a-z0-9]+/g, '-');
        }
        else {
            var digest = new RightHandSideDigest();
            linkId = digest.computeHash(node).toLowerCase();
        }
        if (includePrefix) {
            var production = this.bindings.getAncestor(node, tokens_1.SyntaxKind.Production);
            var productionId = this.getProductionLinkId(production.name);
            return productionId + "-" + linkId;
        }
        return linkId;
    };
    return Resolver;
}());
exports.Resolver = Resolver;
var RightHandSideDigest = (function () {
    function RightHandSideDigest() {
    }
    RightHandSideDigest.prototype.computeHash = function (node) {
        this.writer = new stringwriter_1.StringWriter();
        this.writeNode(node.head);
        var hash = crypto_1.createHash("sha1");
        hash.update(this.writer.toString(), "utf8");
        var digest = hash.digest("hex");
        return digest.substr(0, 8);
    };
    RightHandSideDigest.prototype.writeNode = function (node) {
        var _this = this;
        if (!node) {
            return;
        }
        switch (node.kind) {
            case tokens_1.SyntaxKind.Terminal:
                this.writeTerminal(node);
                break;
            case tokens_1.SyntaxKind.UnicodeCharacterLiteral:
                this.writeUnicodeCharacterLiteral(node);
                break;
            case tokens_1.SyntaxKind.Prose:
                this.writeProse(node);
                break;
            case tokens_1.SyntaxKind.Nonterminal:
                this.writeNonterminal(node);
                break;
            case tokens_1.SyntaxKind.EmptyAssertion:
                this.writeEmptyAssertion(node);
                break;
            case tokens_1.SyntaxKind.LexicalGoalAssertion:
                this.writeLexicalGoalAssertion(node);
                break;
            case tokens_1.SyntaxKind.LookaheadAssertion:
                this.writeLookaheadAssertion(node);
                break;
            case tokens_1.SyntaxKind.NoSymbolHereAssertion:
                this.writeNoSymbolHereAssertion(node);
                break;
            case tokens_1.SyntaxKind.ParameterValueAssertion:
                this.writeParameterValueAssertion(node);
                break;
            case tokens_1.SyntaxKind.ProseAssertion:
                this.writeProseAssertion(node);
                break;
            case tokens_1.SyntaxKind.ProseFull:
                this.writeProseFragmentLiteral(node);
                break;
            case tokens_1.SyntaxKind.ProseHead:
                this.writeProseFragmentLiteral(node);
                break;
            case tokens_1.SyntaxKind.ProseMiddle:
                this.writeProseFragmentLiteral(node);
                break;
            case tokens_1.SyntaxKind.ProseTail:
                this.writeProseFragmentLiteral(node);
                break;
            case tokens_1.SyntaxKind.UnicodeCharacterRange:
                this.writeUnicodeCharacterRange(node);
                break;
            case tokens_1.SyntaxKind.ButNotSymbol:
                this.writeButNotSymbol(node);
                break;
            case tokens_1.SyntaxKind.OneOfSymbol:
                this.writeOneOfSymbol(node);
                break;
            case tokens_1.SyntaxKind.SymbolSpan:
                this.writeSymbolSpan(node);
                break;
            case tokens_1.SyntaxKind.SymbolSet:
                this.writeSymbolSet(node);
                break;
            case tokens_1.SyntaxKind.ArgumentList:
                this.writeArgumentList(node);
                break;
            case tokens_1.SyntaxKind.Argument:
                this.writeArgument(node);
                break;
            case tokens_1.SyntaxKind.Identifier:
                this.writeIdentifier(node);
                break;
            default:
                if ((node.kind >= tokens_1.SyntaxKind.FirstKeyword && node.kind <= tokens_1.SyntaxKind.LastKeyword) ||
                    (node.kind >= tokens_1.SyntaxKind.FirstPunctuation && node.kind <= tokens_1.SyntaxKind.LastPunctuation)) {
                    this.writeToken(node);
                    break;
                }
                else {
                    nodes_1.forEachChild(node, function (child) { return _this.writeNode(child); });
                    break;
                }
        }
    };
    RightHandSideDigest.prototype.write = function (text) {
        if (text) {
            if (this.spaceRequested && this.writer.size > 0) {
                this.spaceRequested = false;
                this.writer.write(" ");
            }
            this.writer.write(text);
        }
    };
    RightHandSideDigest.prototype.writeToken = function (node) {
        this.write(tokens_1.tokenToString(node.kind));
        this.spaceRequested = true;
    };
    RightHandSideDigest.prototype.writeTerminal = function (node) {
        this.write("`");
        this.write(node.text);
        this.write("`");
        this.writeNode(node.questionToken);
        this.spaceRequested = true;
    };
    RightHandSideDigest.prototype.writeUnicodeCharacterLiteral = function (node) {
        this.write("<");
        this.write(node.text);
        this.write(">");
        this.writeNode(node.questionToken);
        this.spaceRequested = true;
    };
    RightHandSideDigest.prototype.writeProse = function (node) {
        this.write("> ");
        for (var _i = 0, _a = node.fragments; _i < _a.length; _i++) {
            var fragment = _a[_i];
            this.writeNode(fragment);
        }
    };
    RightHandSideDigest.prototype.writeNonterminal = function (node) {
        this.writeNode(node.name);
        this.writeNode(node.argumentList);
        this.writeNode(node.questionToken);
        this.spaceRequested = true;
    };
    RightHandSideDigest.prototype.writeArgumentList = function (node) {
        this.write("[");
        for (var i = 0; i < node.elements.length; ++i) {
            if (i > 0) {
                this.write(", ");
            }
            this.writeNode(node.elements[i]);
        }
        this.write("]");
    };
    RightHandSideDigest.prototype.writeArgument = function (node) {
        this.writeNode(node.operatorToken);
        this.writeNode(node.name);
    };
    RightHandSideDigest.prototype.writeEmptyAssertion = function (node) {
        this.write("[empty]");
        this.spaceRequested = true;
    };
    RightHandSideDigest.prototype.writeLexicalGoalAssertion = function (node) {
        this.write("[lexical goal ");
        this.writeNode(node.symbol);
        this.spaceRequested = false;
        this.write("]");
        this.spaceRequested = true;
    };
    RightHandSideDigest.prototype.writeLookaheadAssertion = function (node) {
        this.write("[lookahead ");
        this.writeNode(node.operatorToken);
        this.writeNode(node.lookahead);
        this.spaceRequested = false;
        this.write("]");
        this.spaceRequested = true;
    };
    RightHandSideDigest.prototype.writeNoSymbolHereAssertion = function (node) {
        this.write("[no ");
        for (var i = 0; i < node.symbols.length; ++i) {
            if (i > 0) {
                this.write(" or ");
            }
            this.writeNode(node.symbols[i]);
            this.spaceRequested = false;
        }
        this.write(" here]");
    };
    RightHandSideDigest.prototype.writeParameterValueAssertion = function (node) {
        this.write("[");
        this.writeToken(node.operatorToken);
        this.spaceRequested = false;
        this.writeNode(node.name);
        this.write("]");
        this.spaceRequested = true;
    };
    RightHandSideDigest.prototype.writeProseAssertion = function (node) {
        this.write("[>");
        this.spaceRequested = false;
        for (var _i = 0, _a = node.fragments; _i < _a.length; _i++) {
            var fragment = _a[_i];
            if (fragment.kind === tokens_1.SyntaxKind.Identifier) {
                this.write("|");
                this.writeNode(fragment);
                this.spaceRequested = false;
                this.write("|");
            }
            else {
                this.writeNode(fragment);
            }
        }
        this.write("]");
        this.spaceRequested = true;
    };
    RightHandSideDigest.prototype.writeProseFragmentLiteral = function (node) {
        this.write(node.text);
    };
    RightHandSideDigest.prototype.writeUnicodeCharacterRange = function (node) {
        this.writeNode(node.left);
        this.writeNode(node.throughKeyword);
        this.writeNode(node.right);
        this.spaceRequested = true;
    };
    RightHandSideDigest.prototype.writeButNotSymbol = function (node) {
        this.writeNode(node.left);
        this.writeNode(node.butKeyword);
        this.writeNode(node.notKeyword);
        this.writeNode(node.right);
        this.spaceRequested = true;
    };
    RightHandSideDigest.prototype.writeOneOfSymbol = function (node) {
        this.write("one of ");
        for (var i = 0; i < node.symbols.length; ++i) {
            if (i > 0) {
                this.write(" or ");
            }
            this.writeNode(node.symbols[i]);
            this.spaceRequested = false;
        }
        this.spaceRequested = true;
    };
    RightHandSideDigest.prototype.writeSymbolSpan = function (node) {
        this.writeNode(node.symbol);
        this.writeNode(node.next);
    };
    RightHandSideDigest.prototype.writeSymbolSet = function (node) {
        this.write("{ ");
        for (var i = 0; i < node.elements.length; ++i) {
            if (i > 0) {
                this.write(", ");
            }
            this.writeNode(node.elements[i]);
            this.spaceRequested = false;
        }
        this.write(" }");
        this.spaceRequested = true;
    };
    RightHandSideDigest.prototype.writeIdentifier = function (node) {
        this.write(node.text);
    };
    return RightHandSideDigest;
}());
function isAssertion(node) {
    if (node) {
        switch (node.kind) {
            case tokens_1.SyntaxKind.EmptyAssertion:
            case tokens_1.SyntaxKind.LookaheadAssertion:
            case tokens_1.SyntaxKind.LexicalGoalAssertion:
            case tokens_1.SyntaxKind.NoSymbolHereAssertion:
            case tokens_1.SyntaxKind.ParameterValueAssertion:
            case tokens_1.SyntaxKind.ProseAssertion:
            case tokens_1.SyntaxKind.InvalidAssertion:
                return true;
        }
    }
    return false;
}
function getSymbolMeaning(node) {
    switch (node.kind) {
        case tokens_1.SyntaxKind.Parameter:
        case tokens_1.SyntaxKind.Argument:
        case tokens_1.SyntaxKind.ParameterValueAssertion:
            return symbols_1.SymbolKind.Parameter;
    }
    return symbols_1.SymbolKind.Production;
}
//# sourceMappingURL=checker.js.map
