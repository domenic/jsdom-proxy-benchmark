"use strict";
/*!
 *  Copyright 2015 Ron Buckton (rbuckton@chronicles.org)
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
// NOTE: grammarkdown requires a minimum of ES5.
if (typeof Object.create !== "function")
    throw new Error("Grammarkdown requires a minimum host engine of ES5.");
var dictionaryModeKey = "__DICTIONARY_MODE__";
var hasOwnProperty = Object.prototype.hasOwnProperty;
var ObjectModeHelper = (function () {
    function ObjectModeHelper() {
    }
    return ObjectModeHelper;
}());
var Dictionary = (function () {
    function Dictionary(object) {
        delete (this[dictionaryModeKey] = undefined, this)[dictionaryModeKey];
        if (Array.isArray(object)) {
            for (var _i = 0, object_1 = object; _i < object_1.length; _i++) {
                var _a = object_1[_i], key = _a[0], value = _a[1];
                this[key] = value;
            }
        }
        else {
            for (var key in object)
                if (hasOwnProperty.call(object, key)) {
                    this[key] = object[key];
                }
        }
    }
    Dictionary.has = function (object, key) {
        return key in object;
    };
    Dictionary.get = function (object, key) {
        return object[key];
    };
    Dictionary.getOrUpdate = function (object, key, value) {
        return key in object ? object[key] : object[key] = value;
    };
    Dictionary.getOrCreate = function (object, key, factory) {
        return key in object ? object[key] : object[key] = factory(key);
    };
    Dictionary.set = function (object, key, value) {
        return object[key] = value, object;
    };
    Dictionary.pick = function (object, key) {
        if (key in object) {
            var value = object[key];
            delete object[key];
            return value;
        }
    };
    Dictionary.pickRange = function (object, keys) {
        var result = new Dictionary();
        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
            var key = keys_1[_i];
            if (key in object) {
                result[key] = object[key];
                delete object[key];
            }
        }
        return result;
    };
    Dictionary.pickWhere = function (object, callbackfn, thisArg) {
        var result = new Dictionary();
        for (var key in object) {
            var value = object[key];
            if (callbackfn.call(thisArg, value, key, object)) {
                result[key] = value;
                delete object[key];
            }
        }
        return result;
    };
    Dictionary.delete = function (object, key) {
        return delete object[key];
    };
    Dictionary.deleteWhere = function (object, callbackfn, thisArg) {
        for (var key in object) {
            if (callbackfn.call(thisArg, object[key], key, object)) {
                delete object[key];
            }
        }
    };
    Dictionary.clear = function (object) {
        for (var key in object) {
            delete object[key];
        }
    };
    Dictionary.assign = function (target) {
        var sources = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            sources[_i - 1] = arguments[_i];
        }
        for (var _a = 0, sources_1 = sources; _a < sources_1.length; _a++) {
            var source = sources_1[_a];
            for (var key in source)
                if (hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
        }
        return target;
    };
    Dictionary.merge = function (target) {
        var sources = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            sources[_i - 1] = arguments[_i];
        }
        for (var _a = 0, sources_2 = sources; _a < sources_2.length; _a++) {
            var source = sources_2[_a];
            for (var key in source)
                if (hasOwnProperty.call(source, key)) {
                    if (!(key in target)) {
                        target[key] = source[key];
                    }
                }
        }
        return target;
    };
    Dictionary.from = function (array, keySelector, elementSelector) {
        var dictionary = new Dictionary();
        for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
            var value = array_1[_i];
            dictionary[keySelector(value)] = elementSelector ? elementSelector(value) : value;
        }
        return dictionary;
    };
    Dictionary.forEach = function (object, callbackfn, thisArg) {
        for (var key in object) {
            var value = object[key];
            callbackfn.call(thisArg, value, key, object);
        }
    };
    Dictionary.map = function (object, callbackfn, thisArg) {
        var result = new Dictionary();
        for (var key in object) {
            var value = object[key];
            var mappedValue = callbackfn.call(thisArg, value, key, object);
            result[key] = mappedValue;
        }
        return result;
    };
    Dictionary.mapPairs = function (object, callbackfn, thisArg) {
        var result = new Dictionary();
        for (var key in object) {
            var value = object[key];
            var _a = callbackfn.call(thisArg, value, key, object), mappedKey = _a[0], mappedValue = _a[1];
            result[mappedKey] = mappedValue;
        }
        return result;
    };
    Dictionary.mapWith = function (object, callbacks) {
        var result = new Dictionary();
        for (var key in object) {
            if (hasOwnProperty.call(callbacks, key)) {
                result[key] = callbacks[key](object[key], key, object);
            }
        }
        return result;
    };
    Dictionary.mapPairsWith = function (object, callbacks) {
        var result = new Dictionary();
        for (var key in object) {
            if (hasOwnProperty.call(callbacks, key)) {
                var _a = callbacks[key](object[key], key, object), mappedKey = _a[0], mappedValue = _a[1];
                result[mappedKey] = mappedValue;
            }
        }
        return result;
    };
    Dictionary.filter = function (object, callbackfn, thisArg) {
        var newObject = new Dictionary();
        for (var key in object) {
            var value = object[key];
            if (callbackfn.call(thisArg, value, key, object)) {
                newObject[key] = value;
            }
        }
        return newObject;
    };
    Dictionary.clone = function (object) {
        return new Dictionary(object);
    };
    Dictionary.cloneReadonly = function (object) {
        var clone = new Dictionary(object);
        var savedPrototype = ObjectModeHelper.prototype;
        ObjectModeHelper.prototype = clone;
        new ObjectModeHelper();
        ObjectModeHelper.prototype = savedPrototype;
        Object.freeze(clone);
        return clone;
    };
    Dictionary.count = function (object, callbackfn, thisArg) {
        var count = 0;
        for (var key in object) {
            var value = object[key];
            if (!callbackfn || callbackfn.call(thisArg, value, key, object)) {
                count++;
            }
        }
        return count;
    };
    Dictionary.some = function (object, callbackfn, thisArg) {
        for (var key in object) {
            var value = object[key];
            if (!callbackfn || callbackfn.call(thisArg, value, key, object)) {
                return true;
            }
        }
        return false;
    };
    Dictionary.every = function (object, callbackfn, thisArg) {
        var any = false;
        for (var key in object) {
            var value = object[key];
            if (!callbackfn.call(thisArg, value, key, object)) {
                return false;
            }
            any = true;
        }
        return any;
    };
    Dictionary.find = function (object, callbackfn, thisArg) {
        for (var key in object) {
            var value = object[key];
            if (callbackfn.call(value, key, object)) {
                return value;
            }
        }
        return undefined;
    };
    Dictionary.findKey = function (object, callbackfn, thisArg) {
        for (var key in object) {
            var value = object[key];
            if (callbackfn.call(value, key, object)) {
                return key;
            }
        }
        return undefined;
    };
    Dictionary.first = function (object, callbackfn, thisArg) {
        for (var key in object) {
            var value = object[key];
            if (!callbackfn || callbackfn.call(value, key, object)) {
                return value;
            }
        }
    };
    Dictionary.firstPair = function (object, callbackfn, thisArg) {
        for (var key in object) {
            var value = object[key];
            if (!callbackfn || callbackfn.call(value, key, object)) {
                return [key, value];
            }
        }
    };
    Dictionary.last = function (object, callbackfn, thisArg) {
        var result;
        for (var key in object) {
            var value = object[key];
            if (!callbackfn || callbackfn.call(value, key, object)) {
                result = value;
            }
        }
        return result;
    };
    Dictionary.lastPair = function (object, callbackfn, thisArg) {
        var result;
        for (var key in object) {
            var value = object[key];
            if (!callbackfn || callbackfn.call(value, key, object)) {
                result = [key, value];
            }
        }
        return result;
    };
    Dictionary.reverse = function (object) {
        var result = new Dictionary();
        var keys = Dictionary.keys(object);
        for (var i = keys.length - 1; i >= 0; i--) {
            result[keys[i]] = object[keys[i]];
        }
        return result;
    };
    Dictionary.sort = function (object, callbackfn) {
        if (callbackfn === void 0) { callbackfn = function (a, b) { return compare(a[0], b[0]); }; }
        var entries = Dictionary.entries(object);
        entries.sort(callbackfn);
        return new Dictionary(entries);
    };
    Dictionary.keyOf = function (object, value) {
        for (var key in object) {
            if (object[key] === value) {
                return key;
            }
        }
        return undefined;
    };
    Dictionary.includes = function (object, value) {
        for (var key in object) {
            if (object[key] === value) {
                return true;
            }
        }
        return false;
    };
    Dictionary.contains = function (object, other) {
        if (object === other)
            return true;
        if (!object || !other)
            return false;
        for (var key in other)
            if (hasOwnProperty.call(other, key)) {
                if (!(key in object))
                    return false;
                if (object[key] !== other[key])
                    return false;
            }
        return true;
    };
    Dictionary.equals = function (object, other) {
        if (object === other)
            return true;
        if (!object || !other)
            return false;
        for (var key in object) {
            if (!hasOwnProperty.call(other, key))
                return false;
            if (object[key] !== other[key])
                return false;
        }
        for (var key in other)
            if (hasOwnProperty.call(other, key)) {
                if (!(key in object))
                    return false;
            }
        return true;
    };
    Dictionary.reduce = function (object, callbackfn, initialValue) {
        var aggregate = initialValue;
        for (var key in object) {
            var value = object[key];
            aggregate = callbackfn(aggregate, value, key, object);
        }
        return aggregate;
    };
    Dictionary.turn = function (object, callbackfn, memo) {
        if (memo === void 0) { memo = object; }
        for (var key in object) {
            var value = object[key];
            callbackfn(memo, value, key, object);
        }
        return memo;
    };
    Dictionary.invert = function (object) {
        var inverted = new Dictionary();
        for (var key in object) {
            inverted["" + object[key]] = key;
        }
        return inverted;
    };
    Dictionary.keys = function (object) {
        var result = [];
        for (var key in object) {
            result.push(key);
        }
        return result;
    };
    Dictionary.values = function (object) {
        var result = [];
        for (var key in object) {
            result.push(object[key]);
        }
        return result;
    };
    Dictionary.entries = function (object) {
        var result = [];
        for (var key in object) {
            result.push([key, object[key]]);
        }
        return result;
    };
    Dictionary.toObject = function (object) {
        var result = {};
        for (var key in object) {
            result[key] = object[key];
        }
        return result;
    };
    Dictionary.toArray = function (object, callbackfn, thisArg) {
        var result = [];
        for (var key in object) {
            result.push(callbackfn.call(thisArg, object[key], key, object));
        }
        return result;
    };
    Dictionary.increment = function (object, key, offsetValue) {
        var value = object[key] || 0;
        object[key] = value + (offsetValue || 1);
        return value;
    };
    return Dictionary;
}());
exports.Dictionary = Dictionary;
Dictionary.prototype = createEmptyPrototype();
function binarySearch(array, value) {
    var low = 0;
    var high = array.length - 1;
    while (low <= high) {
        var middle = low + ((high - low) >> 1);
        var midValue = array[middle];
        if (midValue === value) {
            return middle;
        }
        else if (midValue > value) {
            high = middle - 1;
        }
        else {
            low = middle + 1;
        }
    }
    return ~low;
}
exports.binarySearch = binarySearch;
function compareStrings(x, y, ignoreCase) {
    return ignoreCase
        ? compare(x && x.toLocaleLowerCase(), y && y.toLocaleLowerCase())
        : compare(x, y);
}
exports.compareStrings = compareStrings;
function compare(x, y) {
    if (x === y)
        return 0;
    if (x === undefined || x === null)
        return -1;
    if (y === undefined || y === null)
        return +1;
    if (x < y)
        return -1;
    if (x > y)
        return +1;
    return 0;
}
exports.compare = compare;
var Position;
(function (Position) {
    function create(line, character) {
        return { line: line, character: character };
    }
    Position.create = create;
    function clone(position) {
        return create(position.line, position.character);
    }
    Position.clone = clone;
    function compare(left, right) {
        if (left.line < right.line)
            return -1;
        if (left.line > right.line)
            return +1;
        if (left.character < right.character)
            return -1;
        if (left.character > right.character)
            return +1;
        return 0;
    }
    Position.compare = compare;
    function equals(left, right) {
        return left.line === right.line
            && left.character === right.character;
    }
    Position.equals = equals;
})(Position = exports.Position || (exports.Position = {}));
var Range;
(function (Range) {
    function create(start, end) {
        return { start: start, end: end };
    }
    Range.create = create;
    function clone(range) {
        return create(Position.clone(range.start), Position.clone(range.end));
    }
    Range.clone = clone;
    function collapseToStart(range) {
        return create(range.start, range.start);
    }
    Range.collapseToStart = collapseToStart;
    function collapseToEnd(range) {
        return create(range.end, range.end);
    }
    Range.collapseToEnd = collapseToEnd;
    function isCollapsed(range) {
        return Position.compare(range.start, range.end) >= 0;
    }
    Range.isCollapsed = isCollapsed;
    function contains(left, right) {
        return Position.compare(left.start, right.start) <= 0
            && Position.compare(left.end, right.end) >= 0;
    }
    Range.contains = contains;
    function containsPosition(range, position) {
        return Position.compare(range.start, position) <= 0
            && Position.compare(range.end, position) >= 0;
    }
    Range.containsPosition = containsPosition;
    function intersects(left, right) {
        return containsPosition(left, right.start)
            || containsPosition(left, right.end);
    }
    Range.intersects = intersects;
    function equals(left, right) {
        return Position.equals(left.start, right.start)
            && Position.equals(left.end, right.end);
    }
    Range.equals = equals;
})(Range = exports.Range || (exports.Range = {}));
function createEmptyPrototype() {
    if (Object.create) {
        return Object.freeze(Object.create(null));
    }
    var prototype = {};
    for (var _i = 0, _a = ["constructor", "toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable"]; _i < _a.length; _i++) {
        var name_1 = _a[_i];
        delete prototype[name_1];
        if (typeof prototype[name_1] !== "undefined") {
            prototype[name_1] = undefined;
        }
    }
    return prototype;
}
//# sourceMappingURL=core.js.map
