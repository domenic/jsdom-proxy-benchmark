import { CancellationToken } from "prex";
import { DiagnosticMessages } from "./diagnostics";
import { SyntaxKind } from "./tokens";
import { BindingTable } from "./binder";
import { CompilerOptions } from "./options";
import { Node, SourceFile, Identifier, Parameter, RightHandSide, Production } from "./nodes";
import { NodeNavigator } from "./navigator";
export declare class Checker {
    private checkedFileSet;
    private bindings;
    private diagnostics;
    private binder;
    private innerResolver;
    private sourceFile;
    private noStrictParametricProductions;
    private productionParametersByName;
    private cancellationToken;
    constructor(bindings: BindingTable, diagnostics: DiagnosticMessages, options?: CompilerOptions, cancellationToken?: CancellationToken);
    readonly resolver: Resolver;
    checkSourceFile(sourceFile: SourceFile): void;
    protected createResolver(bindings: BindingTable): Resolver;
    private preprocessSourceElement(node);
    private preprocessDefine(node);
    private checkGrammarDefine(node);
    private checkSourceElement(node);
    private checkProduction(node);
    private checkProductionNonStrict(node);
    private getProductionParametersByName(node);
    private checkProductionStrict(thisProduction);
    private checkGrammarProduction(node);
    private checkParameterList(node);
    private checkGrammarParameterList(node);
    private checkParameter(node);
    private checkOneOfList(node);
    private checkGrammarOneOfList(node);
    private checkRightHandSideList(node);
    private checkGrammarRightHandSideList(node);
    private checkRightHandSide(node);
    private checkLinkReference(node);
    private checkGrammarLinkReference(node);
    private checkSymbolSpan(node);
    private checkGrammarSymbolSpan(node);
    private checkSymbolSpanOrHigher(node);
    private checkProse(node);
    private checkSymbolSpanRest(node);
    private checkGrammarSymbolSpanRest(node);
    private checkSymbolOrHigher(node);
    private checkAssertion(node);
    private checkGrammarAssertionHead(node);
    private checkGrammarAssertionTail(node);
    private checkEmptyAssertion(node);
    private checkGrammarEmptyAssertion(node);
    private checkLookaheadAssertion(node);
    private checkGrammarLookaheadAssertion(node);
    private checkSymbolSet(node);
    private checkGrammarSymbolSet(node);
    private checkLexicalGoalAssertion(node);
    private checkGrammarLexicalGoalAssertion(node);
    private checkNoSymbolHereAssertion(node);
    private checkGrammarNoSymbolHereAssertion(node);
    private checkParameterValueAssertion(node);
    private checkGrammarParameterValueAssertion(node);
    private checkProseAssertion(node);
    private checkGrammarProseAssertionHead(node);
    private checkProseFragment(fragment);
    private checkProseFragmentLiteral(node);
    private reportInvalidAssertion(node);
    private checkButNotSymbolOrHigher(node);
    private checkButNotSymbol(node);
    private checkGrammarButNotSymbol(node);
    private checkUnarySymbolOrHigher(node);
    private checkOneOfSymbol(node);
    private checkGrammarOneOfSymbol(node);
    private checkOptionalSymbolOrHigher(node);
    private checkPrimarySymbol(node, allowOptional?);
    private checkGrammarOptionalSymbol(node, allowOptional);
    private checkTerminal(node, allowOptional?);
    private checkGrammarTerminal(node);
    private checkGrammarUnicodeCharacterRange(node);
    private checkUnicodeCharacterRange(node);
    private checkUnicodeCharacterLiteral(node, allowOptional?);
    private checkGrammarUnicodeCharacterLiteral(node);
    private checkPlaceholder(node);
    private checkNonterminal(node, allowOptional?);
    private checkNonterminalNonStrict(node);
    private checkNonterminalStrict(node);
    private checkArgumentList(node);
    private checkGrammarArgumentList(node);
    private checkArgument(node);
    private checkGrammarArgument(node);
    private reportInvalidSymbol(node);
    private checkIdentifier(node);
    private checkGrammarIdentifier(node);
    private reportInvalidSourceElement(node);
    private resolveSymbol(location, name, meaning, diagnosticMessage?);
    private reportGrammarError(pos, diagnosticMessage, arg0?, arg1?, arg2?);
    private reportGrammarErrorForNode(location, diagnosticMessage, arg0?, arg1?, arg2?);
}
export declare class Resolver {
    private bindings;
    constructor(bindings: BindingTable);
    getParent(node: Node): Node;
    createNavigator(node: Node): NodeNavigator;
    getSourceFileOfNode(node: Node): SourceFile;
    getDeclarations(node: Identifier): (SourceFile | Parameter | Production)[];
    getReferences(node: Identifier): Node<SyntaxKind>[];
    getProductionLinkId(node: Identifier): string;
    getRightHandSideLinkId(node: RightHandSide, includePrefix: boolean): string;
}
