/*!
 *  Copyright 2015 Ron Buckton (rbuckton@chronicles.org)
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
export interface DictionaryLike<T> {
    [key: string]: T;
    [key: number]: T;
}
export declare class Dictionary<T> {
    private "Dictionary<T>";
    constructor(object?: DictionaryLike<T> | [string, T][]);
    [key: string]: T;
    [key: number]: T;
    static has<T>(object: Dictionary<T>, key: string | number): boolean;
    static get<T>(object: Dictionary<T>, key: string | number): T;
    static getOrUpdate<T>(object: Dictionary<T>, key: string | number, value: T): T;
    static getOrCreate<T>(object: Dictionary<T>, key: string | number, factory: (key: string | number) => T): T;
    static set<T>(object: Dictionary<T>, key: string | number, value: T): Dictionary<T>;
    static pick<T>(object: Dictionary<T>, key: string | number): T;
    static pickRange<T>(object: Dictionary<T>, keys: string[]): Dictionary<T>;
    static pickWhere<T>(object: Dictionary<T>, callbackfn: (value: T, key: string, object: Dictionary<T>) => boolean, thisArg?: any): Dictionary<T>;
    static delete<T>(object: Dictionary<T>, key: string | number): boolean;
    static deleteWhere<T>(object: Dictionary<T>, callbackfn: (value: T, key: string, object: Dictionary<T>) => boolean, thisArg?: any): void;
    static clear<T>(object: Dictionary<T>): void;
    static assign<T>(target: Dictionary<T>, ...sources: DictionaryLike<T>[]): Dictionary<T>;
    static merge<T>(target: Dictionary<T>, ...sources: DictionaryLike<T>[]): Dictionary<T>;
    static from<T>(array: T[], keySelector: (value: T) => string | number): Dictionary<T>;
    static from<T, U>(array: T[], keySelector: (value: T) => string | number, elementSelector?: (value: T) => U): Dictionary<U>;
    static forEach<T>(object: Dictionary<T>, callbackfn: (value: T, key: string, object: Dictionary<T>) => void, thisArg?: any): void;
    static map<T, U>(object: Dictionary<T>, callbackfn: (value: T, key: string, object: Dictionary<T>) => U, thisArg?: any): Dictionary<U>;
    static mapPairs<T, U>(object: Dictionary<T>, callbackfn: (value: T, key: string, object: Dictionary<T>) => [string, U], thisArg?: any): Dictionary<U>;
    static mapWith<T, U>(object: Dictionary<T>, callbacks: DictionaryLike<(value: T, key: string, object: Dictionary<T>) => U>): Dictionary<U>;
    static mapPairsWith<T, U>(object: Dictionary<T>, callbacks: DictionaryLike<(value: T, key: string, object: Dictionary<T>) => [string | number, U]>): Dictionary<U>;
    static filter<T>(object: Dictionary<T>, callbackfn: (value: T, key: string, object: Dictionary<T>) => boolean, thisArg?: any): Dictionary<T>;
    static clone<T>(object: Dictionary<T>): Dictionary<T>;
    static cloneReadonly<T>(object: Dictionary<T>): ReadonlyDictionary<T>;
    static count<T>(object: Dictionary<T>, callbackfn?: (value: T, key: string, object: Dictionary<T>) => boolean, thisArg?: any): number;
    static some<T>(object: Dictionary<T>, callbackfn?: (value: T, key: string, object: Dictionary<T>) => boolean, thisArg?: any): boolean;
    static every<T>(object: Dictionary<T>, callbackfn: (value: T, key: string, object: Dictionary<T>) => boolean, thisArg?: any): boolean;
    static find<T>(object: Dictionary<T>, callbackfn: (value: T, key: string, object: Dictionary<T>) => boolean, thisArg?: any): T;
    static findKey<T>(object: Dictionary<T>, callbackfn: (value: T, key: string, object: Dictionary<T>) => boolean, thisArg?: any): string;
    static first<T>(object: Dictionary<T>, callbackfn?: (value: T, key: string, object: Dictionary<T>) => boolean, thisArg?: any): T;
    static firstPair<T>(object: Dictionary<T>, callbackfn?: (value: T, key: string, object: Dictionary<T>) => boolean, thisArg?: any): [string, T];
    static last<T>(object: Dictionary<T>, callbackfn?: (value: T, key: string, object: Dictionary<T>) => boolean, thisArg?: any): T;
    static lastPair<T>(object: Dictionary<T>, callbackfn?: (value: T, key: string, object: Dictionary<T>) => boolean, thisArg?: any): [string, T];
    static reverse<T>(object: Dictionary<T>): Dictionary<T>;
    static sort<T>(object: Dictionary<T>, callbackfn?: (a: [string, T], b: [string, T]) => number): Dictionary<T>;
    static keyOf<T>(object: Dictionary<T>, value: T): string;
    static includes<T>(object: Dictionary<T>, value: T): boolean;
    static contains<T>(object: Dictionary<T>, other: DictionaryLike<T>): boolean;
    static equals<T>(object: Dictionary<T>, other: DictionaryLike<T>): boolean;
    static reduce<T, U>(object: Dictionary<T>, callbackfn: (previousValue: U, value: T, key: string, object: Dictionary<T>) => U, initialValue: U): U;
    static turn<T>(object: Dictionary<T>, callbackfn: (memo: Dictionary<T>, value: T, key: string, object: Dictionary<T>) => void, memo?: Dictionary<T>): Dictionary<T>;
    static turn<T, U>(object: Dictionary<T>, callbackfn: (memo: Dictionary<U>, value: T, key: string, object: Dictionary<T>) => void, memo: Dictionary<U>): Dictionary<U>;
    static invert<T extends string | number>(object: Dictionary<T>): Dictionary<string>;
    static keys<T>(object: Dictionary<T>): string[];
    static values<T>(object: Dictionary<T>): T[];
    static entries<T>(object: Dictionary<T>): [string, T][];
    static toObject<T>(object: Dictionary<T>): DictionaryLike<T>;
    static toArray<T, U>(object: Dictionary<T>, callbackfn: (value: T, key: string, object: Dictionary<T>) => U, thisArg?: any): U[];
    static increment(object: Dictionary<number>, key: string | number, offsetValue?: number): number;
}
export interface ReadonlyDictionary<T> extends Dictionary<T> {
    readonly [key: number]: T;
    readonly [key: string]: T;
}
export declare function binarySearch(array: number[], value: number): number;
export declare function compareStrings(x: string, y: string, ignoreCase?: boolean): number;
export declare function compare(x: any, y: any): number;
export interface TextRange {
    pos: number;
    end: number;
}
export interface Position {
    line: number;
    character: number;
}
export declare namespace Position {
    function create(line: number, character: number): Position;
    function clone(position: Position): Position;
    function compare(left: Position, right: Position): number;
    function equals(left: Position, right: Position): boolean;
}
export interface Range {
    start: Position;
    end: Position;
}
export declare namespace Range {
    function create(start: Position, end: Position): Range;
    function clone(range: Range): Range;
    function collapseToStart(range: Range): Range;
    function collapseToEnd(range: Range): Range;
    function isCollapsed(range: Range): boolean;
    function contains(left: Range, right: Range): boolean;
    function containsPosition(range: Range, position: Position): boolean;
    function intersects(left: Range, right: Range): boolean;
    function equals(left: Range, right: Range): boolean;
}
