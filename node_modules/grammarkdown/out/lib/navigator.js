"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tokens_1 = require("./tokens");
var NodeNavigator = (function () {
    function NodeNavigator(sourceFileOrNavigator) {
        if (sourceFileOrNavigator instanceof NodeNavigator) {
            var navigator_1 = sourceFileOrNavigator;
            this.initialize(navigator_1.sourceFile, navigator_1.nodeStack.slice(), navigator_1.shapeStack.slice(), navigator_1.edgeStack.slice(), navigator_1.arrayStack.slice(), navigator_1.offsetStack.slice());
        }
        else {
            var sourceFile = sourceFileOrNavigator;
            this.initialize(sourceFile, [sourceFile], [sourceFile.getEdges()], [-1], [undefined], [0]);
        }
    }
    NodeNavigator.prototype.initialize = function (sourceFile, nodeStack, shapeStack, edgeStack, arrayStack, offsetStack) {
        this.sourceFile = sourceFile;
        this.nodeStack = nodeStack;
        this.shapeStack = shapeStack;
        this.edgeStack = edgeStack;
        this.arrayStack = arrayStack;
        this.offsetStack = offsetStack;
        this.currentDepth = nodeStack.length - 1;
        this.afterNavigate();
    };
    NodeNavigator.prototype.clone = function () {
        return new NodeNavigator(this);
    };
    NodeNavigator.prototype.getRoot = function () {
        return this.sourceFile;
    };
    NodeNavigator.prototype.getParent = function () {
        return this.parentNode;
    };
    NodeNavigator.prototype.getNode = function () {
        return this.currentNode;
    };
    NodeNavigator.prototype.getKind = function () {
        return this.currentNode.kind;
    };
    NodeNavigator.prototype.getName = function () {
        var edge = this.getEdge();
        return edge ? edge.name : undefined;
    };
    NodeNavigator.prototype.getArray = function () {
        return this.currentArray;
    };
    NodeNavigator.prototype.getOffset = function () {
        return this.currentOffset;
    };
    NodeNavigator.prototype.getDepth = function () {
        return this.currentDepth;
    };
    NodeNavigator.prototype.isArray = function () {
        return this.currentArray !== undefined;
    };
    NodeNavigator.prototype.hasChildren = function (predicate) {
        if (this.hasAnyChildren === undefined) {
            return this.hasAnyChildren = this.hasChild(predicate || matchAny);
        }
        return this.hasAnyChildren;
    };
    NodeNavigator.prototype.hasChild = function (predicate) {
        if (this.hasAnyChildren === false) {
            return false;
        }
        for (var nextEdge = 0; nextEdge < this.currentShape.length; nextEdge++) {
            var edge = this.currentShape[nextEdge];
            if (edge) {
                if (edge.isArray) {
                    var nextArray = edge.readArray(this.currentNode);
                    if (nextArray) {
                        for (var nextOffset = 0; nextOffset < nextArray.length; nextOffset++) {
                            var nextNode = nextArray[nextOffset];
                            if (nextNode && predicate(nextNode)) {
                                return this.hasAnyChildren = true;
                            }
                        }
                    }
                }
                else {
                    var nextNode = edge.read(this.currentNode);
                    if (nextNode && predicate(nextNode)) {
                        return this.hasAnyChildren = true;
                    }
                }
            }
        }
        return false;
    };
    NodeNavigator.prototype.hasAncestor = function (predicate) {
        for (var nextDepth = this.currentDepth - 1; nextDepth >= 0; nextDepth--) {
            var nextNode = this.nodeStack[nextDepth];
            if (!predicate || predicate(nextNode)) {
                return true;
            }
        }
        return false;
    };
    NodeNavigator.prototype.isSamePosition = function (other) {
        if (this === other) {
            return true;
        }
        return this.sourceFile === other.sourceFile
            && this.currentNode === other.currentNode
            && this.currentDepth === other.currentDepth
            && this.currentEdge === other.currentEdge
            && this.currentOffset === other.currentOffset;
    };
    NodeNavigator.prototype.moveToPosition = function (position) {
        var pos = this.sourceFile.lineMap.offsetAt(position);
        var currentDepth = this.currentDepth;
        var nodeStack = this.nodeStack;
        var shapeStack = this.shapeStack;
        var edgeStack = this.edgeStack;
        var arrayStack = this.arrayStack;
        var offsetStack = this.offsetStack;
        var hasChild = this.hasAnyChildren;
        this.copyOnNavigate = true;
        this.moveToRoot();
        if (this.moveToPositionWorker(pos)) {
            return true;
        }
        this.currentDepth = currentDepth;
        this.nodeStack = nodeStack;
        this.shapeStack = shapeStack;
        this.edgeStack = edgeStack;
        this.arrayStack = arrayStack;
        this.offsetStack = offsetStack;
        this.hasAnyChildren = hasChild;
        this.afterNavigate();
        return false;
    };
    NodeNavigator.prototype.moveToPositionWorker = function (pos) {
        if (pos >= this.currentNode.pos && pos < this.currentNode.end) {
            if (this.moveToFirstChild()) {
                do {
                    if (this.moveToPositionWorker(pos)) {
                        return true;
                    }
                } while (this.moveToNextSibling());
                this.moveToParent();
            }
            return true;
        }
        return false;
    };
    NodeNavigator.prototype.moveTo = function (other) {
        if (this === other) {
            return true;
        }
        if (this.sourceFile !== other.sourceFile) {
            return false;
        }
        this.currentDepth = other.currentDepth;
        this.nodeStack = other.nodeStack.slice();
        this.shapeStack = other.shapeStack.slice();
        this.edgeStack = other.edgeStack.slice();
        this.arrayStack = other.arrayStack.slice();
        this.offsetStack = other.offsetStack.slice();
        this.afterNavigate();
        return true;
    };
    NodeNavigator.prototype.moveToRoot = function () {
        if (this.currentDepth > 0) {
            this.beforeNavigate();
            this.reset();
            this.afterNavigate();
        }
        return true;
    };
    NodeNavigator.prototype.moveToParent = function (predicate) {
        if (this.currentDepth > 0) {
            if (!predicate || predicate(this.parentNode)) {
                this.beforeNavigate();
                this.popEdge();
                this.afterNavigate();
                return true;
            }
        }
        return false;
    };
    NodeNavigator.prototype.moveToAncestorOrSelf = function (predicate) {
        return predicate(this.currentNode)
            || this.moveToAncestor(predicate);
    };
    NodeNavigator.prototype.moveToAncestor = function (predicate) {
        for (var nextDepth = this.currentDepth - 1; nextDepth >= 0; nextDepth--) {
            var nextNode = this.nodeStack[nextDepth];
            if (predicate(nextNode)) {
                this.beforeNavigate();
                while (this.currentDepth !== nextDepth) {
                    this.popEdge();
                }
                this.afterNavigate();
                return true;
            }
        }
        return false;
    };
    NodeNavigator.prototype.moveToSourceElement = function () {
        return this.moveToParent(matchSourceElement);
    };
    NodeNavigator.prototype.moveToDeclaration = function () {
        return this.moveToParent(matchParameter)
            || this.moveToParent(matchProduction);
    };
    NodeNavigator.prototype.moveToName = function () {
        if (this.getKind() === tokens_1.SyntaxKind.Identifier) {
            return true;
        }
        else {
            var navigator_2 = this.clone();
            if (navigator_2.moveToAncestorOrSelf(matchParameter)
                && navigator_2.moveToFirstChild("name")) {
                return this.moveTo(navigator_2);
            }
            navigator_2.moveTo(this);
            if (navigator_2.moveToAncestorOrSelf(matchArgument)
                && navigator_2.moveToFirstChild("name")) {
                return this.moveTo(navigator_2);
            }
            navigator_2.moveTo(this);
            if (navigator_2.moveToAncestorOrSelf(matchNonterminal)
                && navigator_2.moveToFirstChild("name")) {
                return this.moveTo(navigator_2);
            }
            navigator_2.moveTo(this);
            if (!navigator_2.hasAncestor(matchProductionBody)
                && navigator_2.moveToAncestorOrSelf(matchProduction)
                && navigator_2.moveToFirstChild("name")) {
                return this.moveTo(navigator_2);
            }
            navigator_2.moveTo(this);
            if (navigator_2.moveToAncestorOrSelf(matchParameterValueAssertion)
                && navigator_2.moveToFirstChild("name")) {
                return this.moveTo(navigator_2);
            }
        }
        return false;
    };
    NodeNavigator.prototype.moveToFirstChild = function (predicateOrName) {
        return this.moveToChild(Navigation.first, Navigation.next, predicateOrName);
    };
    NodeNavigator.prototype.moveToLastChild = function (predicateOrName) {
        return this.moveToChild(Navigation.last, Navigation.previous, predicateOrName);
    };
    NodeNavigator.prototype.moveToFirstElement = function (predicate) {
        return this.moveToElement(Navigation.first, Navigation.next, this.currentArray, this.currentOffset, predicate);
    };
    NodeNavigator.prototype.moveToPreviousElement = function (predicate) {
        return this.moveToElement(Navigation.previous, Navigation.previous, this.currentArray, this.currentOffset, predicate);
    };
    NodeNavigator.prototype.moveToNextElement = function (predicate) {
        return this.moveToElement(Navigation.next, Navigation.next, this.currentArray, this.currentOffset, predicate);
    };
    NodeNavigator.prototype.moveToLastElement = function (predicate) {
        return this.moveToElement(Navigation.last, Navigation.previous, this.currentArray, this.currentOffset, predicate);
    };
    NodeNavigator.prototype.moveToFirstSibling = function (predicateOrName) {
        return this.moveToSibling(Navigation.first, undefined, Navigation.first, Navigation.next, predicateOrName);
    };
    NodeNavigator.prototype.moveToPreviousSibling = function (predicateOrName) {
        return this.moveToSibling(Navigation.previous, Navigation.previous, Navigation.last, Navigation.previous, predicateOrName);
    };
    NodeNavigator.prototype.moveToNextSibling = function (predicateOrName) {
        return this.moveToSibling(Navigation.next, Navigation.next, Navigation.first, Navigation.next, predicateOrName);
    };
    NodeNavigator.prototype.moveToLastSibling = function (predicateOrName) {
        return this.moveToSibling(Navigation.last, undefined, Navigation.last, Navigation.previous, predicateOrName);
    };
    NodeNavigator.prototype.getEdge = function () {
        return this.parentShape ? this.parentShape[this.currentEdge] : undefined;
    };
    NodeNavigator.prototype.beforeNavigate = function () {
        if (this.copyOnNavigate) {
            this.nodeStack = this.nodeStack.slice();
            this.shapeStack = this.shapeStack.slice();
            this.edgeStack = this.edgeStack.slice();
            this.arrayStack = this.arrayStack.slice();
            this.offsetStack = this.offsetStack.slice();
            this.copyOnNavigate = false;
        }
    };
    NodeNavigator.prototype.afterNavigate = function () {
        this.currentNode = this.nodeStack[this.currentDepth];
        this.currentShape = this.shapeStack[this.currentDepth];
        this.currentEdge = this.edgeStack[this.currentDepth];
        this.currentArray = this.arrayStack[this.currentDepth];
        this.currentOffset = this.offsetStack[this.currentDepth];
        this.parentNode = this.currentDepth > 0 ? this.nodeStack[this.currentDepth - 1] : undefined;
        this.parentShape = this.currentDepth > 0 ? this.shapeStack[this.currentDepth - 1] : undefined;
        this.copyOnNavigate = false;
    };
    NodeNavigator.prototype.pushEdge = function () {
        this.nodeStack.push(undefined);
        this.shapeStack.push(undefined);
        this.edgeStack.push(undefined);
        this.arrayStack.push(undefined);
        this.offsetStack.push(1);
        this.hasAnyChildren = undefined;
        this.currentDepth++;
    };
    NodeNavigator.prototype.setEdge = function (node, edge, array, offset) {
        this.nodeStack[this.currentDepth] = node;
        this.shapeStack[this.currentDepth] = node.getEdges();
        this.edgeStack[this.currentDepth] = edge;
        this.arrayStack[this.currentDepth] = array;
        this.offsetStack[this.currentDepth] = offset;
        this.hasAnyChildren = undefined;
    };
    NodeNavigator.prototype.popEdge = function () {
        this.currentDepth--;
        this.nodeStack.pop();
        this.shapeStack.pop();
        this.edgeStack.pop();
        this.arrayStack.pop();
        this.offsetStack.pop();
        this.hasAnyChildren = this.currentNode !== undefined;
    };
    NodeNavigator.prototype.moveToChild = function (initializer, seekDirection, predicateOrName) {
        var predicate = typeof predicateOrName === "function" ? predicateOrName : undefined;
        var name = typeof predicateOrName === "string" ? predicateOrName : undefined;
        var offset = this.currentEdge;
        var length = this.currentShape.length;
        for (var nextEdge = initializer(offset, length); bounded(nextEdge, length); nextEdge = seekDirection(nextEdge, length)) {
            var edge = this.currentShape[nextEdge];
            if (edge && (!name || edge.name === name)) {
                if (edge.isArray) {
                    var nextArray = edge.readArray(this.currentNode);
                    if (nextArray) {
                        var length_1 = nextArray.length;
                        for (var nextOffset = initializer(0, length_1); bounded(nextOffset, length_1); nextOffset = seekDirection(nextOffset, length_1)) {
                            var nextNode = nextArray[nextOffset];
                            if (nextNode && (!predicate || predicate(nextNode))) {
                                this.beforeNavigate();
                                this.pushEdge();
                                this.setEdge(nextNode, nextEdge, nextArray, nextOffset);
                                this.afterNavigate();
                                return true;
                            }
                        }
                    }
                }
                else {
                    var nextNode = edge.read(this.currentNode);
                    if (nextNode && (!predicate || predicate(nextNode))) {
                        this.beforeNavigate();
                        this.pushEdge();
                        this.setEdge(nextNode, nextEdge, /*array*/ undefined, /*offset*/ undefined);
                        this.afterNavigate();
                        return true;
                    }
                }
            }
        }
        return false;
    };
    NodeNavigator.prototype.moveToElement = function (currentArrayInitializer, seekDirection, currentArray, currentOffset, predicateOrName) {
        var predicate = typeof predicateOrName === "function" ? predicateOrName : undefined;
        if (currentArray) {
            var offset = currentOffset;
            var length_2 = currentArray.length;
            for (var nextOffset = currentArrayInitializer(offset, length_2); bounded(nextOffset, length_2); nextOffset = seekDirection(nextOffset, length_2)) {
                var nextNode = currentArray[nextOffset];
                if (nextNode && (!predicate || predicate(nextNode))) {
                    this.beforeNavigate();
                    this.setEdge(nextNode, this.currentEdge, currentArray, nextOffset);
                    this.afterNavigate();
                    return true;
                }
            }
        }
        return false;
    };
    NodeNavigator.prototype.moveToSibling = function (currentEdgeInitializer, currentArrayInitializer, nextArrayInitializer, seekDirection, predicateOrName) {
        var predicate = typeof predicateOrName === "function" ? predicateOrName : undefined;
        var name = typeof predicateOrName === "string" ? predicateOrName : undefined;
        if (this.currentDepth > 0) {
            if (currentArrayInitializer && this.moveToElement(currentArrayInitializer, seekDirection, this.currentArray, this.currentOffset, predicateOrName)) {
                return true;
            }
            var offset = this.currentEdge;
            var length_3 = this.parentShape.length;
            for (var nextEdge = currentEdgeInitializer(offset, length_3); bounded(nextEdge, length_3); nextEdge = seekDirection(nextEdge, length_3)) {
                var edge = this.parentShape[nextEdge];
                if (edge && (!name || edge.name === name)) {
                    if (edge.isArray) {
                        var nextArray = edge.readArray(this.parentNode);
                        if (nextArray) {
                            if (this.moveToElement(nextArrayInitializer, seekDirection, nextArray, 0, predicateOrName)) {
                                return true;
                            }
                        }
                    }
                    else {
                        var nextNode = edge.read(this.parentNode);
                        if (nextNode && (!predicate || predicate(nextNode))) {
                            this.beforeNavigate();
                            this.setEdge(nextNode, nextEdge, /*array*/ undefined, /*offset*/ undefined);
                            this.afterNavigate();
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    };
    NodeNavigator.prototype.reset = function () {
        this.currentDepth = 0;
        this.nodeStack.length = 1;
        this.shapeStack.length = 1;
        this.edgeStack.length = 1;
        this.arrayStack.length = 1;
        this.offsetStack.length = 1;
    };
    return NodeNavigator;
}());
exports.NodeNavigator = NodeNavigator;
var Navigation;
(function (Navigation) {
    function first(offset, length) {
        return 0;
    }
    Navigation.first = first;
    function previous(offset, length) {
        return offset - 1;
    }
    Navigation.previous = previous;
    function same(offset, length) {
        return offset;
    }
    Navigation.same = same;
    function next(offset, length) {
        return offset + 1;
    }
    Navigation.next = next;
    function last(offset, length) {
        return length - 1;
    }
    Navigation.last = last;
})(Navigation || (Navigation = {}));
function bounded(offset, length) {
    return offset >= 0 && offset < length;
}
function matchAny(node) {
    return true;
}
function matchParameter(node) {
    return node.kind === tokens_1.SyntaxKind.Parameter;
}
function matchProduction(node) {
    return node.kind === tokens_1.SyntaxKind.Production;
}
function matchNonterminal(node) {
    return node.kind === tokens_1.SyntaxKind.Nonterminal;
}
function matchArgument(node) {
    return node.kind === tokens_1.SyntaxKind.Argument;
}
function matchProductionBody(node) {
    return node.kind === tokens_1.SyntaxKind.OneOfList
        || node.kind === tokens_1.SyntaxKind.RightHandSideList
        || node.kind === tokens_1.SyntaxKind.RightHandSide;
}
function matchParameterValueAssertion(node) {
    return node.kind === tokens_1.SyntaxKind.ParameterValueAssertion;
}
function matchSourceElement(node) {
    return node.kind === tokens_1.SyntaxKind.Import
        || node.kind === tokens_1.SyntaxKind.Production;
}
//# sourceMappingURL=navigator.js.map
