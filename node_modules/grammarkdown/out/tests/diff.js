"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*!
 *  Copyright 2015 Ron Buckton (rbuckton@chronicles.org)
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
var fs_1 = require("fs");
var os_1 = require("os");
var path_1 = require("path");
var tokens_1 = require("../lib/tokens");
var nodes_1 = require("../lib/nodes");
function writeTokens(test, scanner, lineMap, baselines) {
    var text = "/// " + test + ":" + os_1.EOL;
    var token;
    do {
        token = scanner.scan();
        var message = "SyntaxKind[" + formatKind(token) + "](" + lineMap.formatPosition(scanner.getTokenPos()) + "): ";
        switch (token) {
            case tokens_1.SyntaxKind.ProseFull:
            case tokens_1.SyntaxKind.ProseHead:
            case tokens_1.SyntaxKind.ProseMiddle:
            case tokens_1.SyntaxKind.ProseTail:
                message += scanner.getTokenValue();
                break;
            case tokens_1.SyntaxKind.Identifier:
                message += "" + scanner.getTokenValue();
                break;
            case tokens_1.SyntaxKind.Terminal:
                message += "`" + scanner.getTokenValue() + "`";
                break;
            case tokens_1.SyntaxKind.StringLiteral:
                message += "\"" + scanner.getTokenValue() + "\"";
                break;
            case tokens_1.SyntaxKind.UnicodeCharacterLiteral:
                message += scanner.getTokenText();
                break;
            default:
                message += "" + tokens_1.tokenToString(token);
        }
        text += message + os_1.EOL;
    } while (token !== tokens_1.SyntaxKind.EndOfFileToken);
    return writeBaseline(test + ".tokens", text, baselines);
}
exports.writeTokens = writeTokens;
function writeDiagnostics(test, diagnostics, baselines) {
    var text = undefined;
    diagnostics.forEach(function (message) {
        if (!text) {
            text = "/// " + test + ":" + os_1.EOL;
        }
        text += message + os_1.EOL;
    });
    return writeBaseline(test + ".diagnostics", text, baselines);
}
exports.writeDiagnostics = writeDiagnostics;
function writeNodes(test, sourceFile, baselines) {
    var text = "/// " + test + ":" + os_1.EOL;
    var indents = ["", "  "];
    var indentDepth = 0;
    printNode(sourceFile);
    return writeBaseline(test + ".nodes", text, baselines);
    function getIndent(depth) {
        if (depth >= indents.length) {
            indents[depth] = getIndent(depth - 1) + indents[1];
        }
        return indents[depth];
    }
    function printNode(node) {
        text += getIndent(indentDepth) + formatNode(node, sourceFile) + os_1.EOL;
        indentDepth++;
        nodes_1.forEachChild(node, printNode);
        indentDepth--;
    }
}
exports.writeNodes = writeNodes;
function writeOutput(test, extname, text, baselines) {
    return writeBaseline(test + extname, text, baselines);
}
exports.writeOutput = writeOutput;
function writeBaseline(file, text, baselines) {
    if (baselines) {
        baselines.push(file);
    }
    var localFile = resolveBaseline(file).localFile;
    if (text === undefined) {
        if (fs_1.existsSync(localFile)) {
            fs_1.unlinkSync(localFile);
        }
    }
    else {
        fs_1.writeFileSync(localFile, text, { encoding: "utf8" });
    }
    return file;
}
exports.writeBaseline = writeBaseline;
function compareBaselines(baselines) {
    for (var _i = 0, baselines_1 = baselines; _i < baselines_1.length; _i++) {
        var file = baselines_1[_i];
        var _a = resolveBaseline(file), localFile = _a.localFile, referenceFile = _a.referenceFile;
        var localText = fs_1.existsSync(localFile) ? fs_1.readFileSync(localFile, "utf8") : undefined;
        var referenceText = fs_1.existsSync(referenceFile) ? fs_1.readFileSync(referenceFile, "utf8") : undefined;
        if (localText !== referenceText) {
            throw new Error("The baseline file '" + file + "' has changed.");
        }
    }
}
exports.compareBaselines = compareBaselines;
function compareBaseline(file) {
    var _a = resolveBaseline(file), localFile = _a.localFile, referenceFile = _a.referenceFile;
    var localText = fs_1.existsSync(localFile) ? fs_1.readFileSync(localFile, "utf8") : undefined;
    var referenceText = fs_1.existsSync(referenceFile) ? fs_1.readFileSync(referenceFile, "utf8") : undefined;
    if (localText !== referenceText) {
        throw new Error("The baseline file '" + file + "' has changed.");
    }
}
exports.compareBaseline = compareBaseline;
function resolveBaseline(file) {
    var baselinePath = path_1.resolve(__dirname, "../../baselines");
    var localPath = path_1.resolve(baselinePath, "local");
    var localFile = path_1.resolve(localPath, file);
    var referencePath = path_1.resolve(baselinePath, "reference");
    var referenceFile = path_1.resolve(referencePath, file);
    ensureDirectory(baselinePath);
    ensureDirectory(localPath);
    ensureDirectory(referencePath);
    return { localFile: localFile, referenceFile: referenceFile };
}
function ensureDirectory(path) {
    if (!fs_1.existsSync(path)) {
        fs_1.mkdirSync(path);
    }
}
function formatKind(kind) {
    for (var p in tokens_1.SyntaxKind) {
        if (tokens_1.SyntaxKind[p] === kind) {
            return p;
        }
    }
    return tokens_1.SyntaxKind[kind];
}
function formatNode(node, sourceFile) {
    var text = "(" + sourceFile.lineMap.formatPosition(node.pos) + ")";
    text += "SyntaxKind[" + formatKind(node.kind) + "]";
    switch (node.kind) {
        case tokens_1.SyntaxKind.Identifier:
        case tokens_1.SyntaxKind.Terminal:
        case tokens_1.SyntaxKind.ProseFull:
        case tokens_1.SyntaxKind.ProseHead:
        case tokens_1.SyntaxKind.ProseMiddle:
        case tokens_1.SyntaxKind.ProseTail:
        case tokens_1.SyntaxKind.StringLiteral:
            text += "(text = \"" + node.text + "\")";
            break;
        case tokens_1.SyntaxKind.UnicodeCharacterLiteral:
            text += "(text = " + sourceFile.text.slice(node.pos, node.end) + ")";
            break;
        case tokens_1.SyntaxKind.SourceFile:
            text += "(filename = \"" + path_1.basename(node.filename) + "\")";
            break;
    }
    switch (node.kind) {
        case tokens_1.SyntaxKind.Terminal:
        case tokens_1.SyntaxKind.Nonterminal:
        case tokens_1.SyntaxKind.UnicodeCharacterLiteral:
            if (node.questionToken) {
                text += "?";
            }
            break;
        case tokens_1.SyntaxKind.Argument:
            if (node.operatorToken) {
                switch (node.operatorToken.kind) {
                    case tokens_1.SyntaxKind.QuestionToken:
                        text += "?";
                        break;
                    case tokens_1.SyntaxKind.TildeToken:
                        text += "~";
                        break;
                    case tokens_1.SyntaxKind.PlusToken:
                        text += "+";
                        break;
                }
            }
            break;
    }
    return text;
}
//# sourceMappingURL=diff.js.map
