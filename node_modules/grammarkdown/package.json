{
  "_args": [
    [
      {
        "raw": "grammarkdown@^1.0.7",
        "scope": null,
        "escapedName": "grammarkdown",
        "name": "grammarkdown",
        "rawSpec": "^1.0.7",
        "spec": ">=1.0.7 <2.0.0",
        "type": "range"
      },
      "C:\\Users\\Domenic\\Dropbox\\GitHub\\jsdom-proxy-benchmark\\node_modules\\ecmarkup"
    ]
  ],
  "_from": "grammarkdown@>=1.0.7 <2.0.0",
  "_id": "grammarkdown@1.0.8",
  "_inCache": true,
  "_location": "/grammarkdown",
  "_nodeVersion": "8.1.3",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/grammarkdown-1.0.8.tgz_1501107114673_0.5516501457896084"
  },
  "_npmUser": {
    "name": "rbuckton",
    "email": "rbuckton@chronicles.org"
  },
  "_npmVersion": "5.3.0",
  "_phantomChildren": {},
  "_requested": {
    "raw": "grammarkdown@^1.0.7",
    "scope": null,
    "escapedName": "grammarkdown",
    "name": "grammarkdown",
    "rawSpec": "^1.0.7",
    "spec": ">=1.0.7 <2.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/ecmarkup"
  ],
  "_resolved": "https://registry.npmjs.org/grammarkdown/-/grammarkdown-1.0.8.tgz",
  "_shasum": "c01f9042024b35d20f4d307b3a61513fafe02eff",
  "_shrinkwrap": null,
  "_spec": "grammarkdown@^1.0.7",
  "_where": "C:\\Users\\Domenic\\Dropbox\\GitHub\\jsdom-proxy-benchmark\\node_modules\\ecmarkup",
  "author": {
    "name": "Ron Buckton",
    "email": "rbuckton@chronicles.org",
    "url": "http://github.com/rbuckton"
  },
  "bin": {
    "grammarkdown": "./bin/grammarkdown"
  },
  "bugs": {
    "url": "https://github.com/rbuckton/grammarkdown/issues"
  },
  "dependencies": {
    "prex": "^0.2.0"
  },
  "description": "Markdown-like DSL for defining syntactic grammars for programming languages.",
  "devDependencies": {
    "@types/chai": "^3.4.28",
    "@types/mocha": "^2.2.27",
    "@types/node": "^4.0.29",
    "@types/source-map-support": "^0.2.27",
    "chai": "^2.3.0",
    "del": "^2.0.2",
    "ecmarkup": "^3.2.6",
    "gulp": "^3.9.1",
    "gulp-emu": "^1.0.0",
    "gulp-mocha": "^2.1.0",
    "gulp-sourcemaps": "^2.0.0-alpha",
    "gulp-tsb": "git://github.com/rbuckton/gulp-tsb.git#srcDestMethods",
    "merge2": "^0.3.6",
    "mocha": "^2.2.5",
    "source-map-support": "^0.3.1",
    "typescript": "next"
  },
  "directories": {},
  "dist": {
    "integrity": "sha512-B0J4MOCzlNwZ73S0hkaxwY88R5RN9AHmNxLtkasIvvGO93maa2Cw7G8vu33510gQ1GpvrsRjTq8Mxdzps9osgQ==",
    "shasum": "c01f9042024b35d20f4d307b3a61513fafe02eff",
    "tarball": "https://registry.npmjs.org/grammarkdown/-/grammarkdown-1.0.8.tgz"
  },
  "gitHead": "ec2e2c021420e10a54f2688be7bb3427355b2d6e",
  "homepage": "https://github.com/rbuckton/grammarkdown",
  "keywords": [
    "grammar",
    "language",
    "syntax",
    "dsl",
    "javascript",
    "typescript",
    "ecmascript"
  ],
  "license": "Apache-2.0",
  "main": "./out/lib/index.js",
  "maintainers": [
    {
      "name": "rbuckton",
      "email": "rbuckton@chronicles.org"
    }
  ],
  "name": "grammarkdown",
  "optionalDependencies": {},
  "readme": "# grammarkdown\r\n\r\n## Summary\r\n\r\n`grammarkdown` is a markdown-style parser for syntactic grammars, designed to make it easily to rapidly prototype a grammar and statically verify its consistency.\r\nThe grammar supported by `grammarkdown` is based on the parametric grammar used by ECMA-262 (the JavaScript language standard).\r\n\r\n## Usage\r\n```\r\nSyntax:                   grammarkdown [options] [...files]\r\n\r\nExamples:                 grammarkdown es6.grammar\r\n                          grammarkdown --out es6.md --format markdown es6.grammar\r\n\r\nOptions:\r\n -f, --format FORMAT      The output format.\r\n -h, --help               Prints this message.\r\n     --noChecks           Does not perform static checking of the grammar.\r\n     --noEmit             Does not emit output.\r\n     --noEmitOnError      Does not emit output if there are errors.\r\n -o, --out FILE           Specify the output file.\r\n -v, --version            Prints the version.\r\n```\r\n\r\n## Syntax\r\n\r\nA `grammarkdown` grammar file uses significant whitespace in the form of line terminators and indentation. Tab (ASCII 0x9) characters are preferred,\r\nhowever using multiple spaces for indentation is supported as long as all nested elements have the same amount of leading whitespace.\r\n\r\n#### Productions\r\n\r\nA *Production* consists of a left-hand-side *Nonterminal* followed by a colon (`:`) separator and one or more *right-hand-side* sentences consisting of\r\nvarious forms of *terminal* and *nonterminal* symbols. For example:\r\n\r\n```\r\nNameSpaceImport : `*` `as` ImportedBinding\r\n```\r\n\r\nIt is recommended that *Productions* should follow pascal-case naming conventions, to avoid collision with reserved keywords.\r\n\r\nYou may specify multiple productions for a *Nonterminal* on multiple lines, as follows:\r\n\r\n```\r\nNamedImports : `{` `}`\r\nNamedImports : `{` ImportList `}`\r\nNamedImports : `{` ImportList `,` `}`\r\n```\r\n\r\nYou may also specify multiple left-hand-side sentences for a single production by indenting them:\r\n\r\n```\r\nNamedImports :\r\n    `{` `}`\r\n    `{` ImportList `}`\r\n    `{` ImportList `,` `}`\r\n```\r\n\r\nA *Production* may specify one or more *parameters* that can be used to reuse a *Nonterminal* in various circumstances:\r\n\r\n```\r\nIdentifierReference[Yield] :\r\n    Identifier\r\n    [~Yield] `yield`\r\n```\r\n\r\nA *Production* may also specify a limited set of terminals, by using the `one of` keyphrase:\r\n\r\n```\r\nKeyword :: one of\r\n\t`break`\t\t`do`\t\t`in`\t\t\t`typeof`\r\n\t`case`\t\t`else`\t\t`instanceof`\t`var`\r\n\t`catch`\t\t`export`\t`new`\t\t\t`void`\r\n\t`class`\t\t`extends`\t`return`\t\t`while`\r\n\t`const`\t\t`finally`\t`super`\t\t\t`with`\r\n\t`continue`\t`for`\t\t`switch`\t\t`yield`\r\n\t`debugger`\t`function`\t`this`\r\n\t`default`\t`if`\t\t`throw`\r\n\t`delete`\t`import`\t`try`\r\n```\r\n\r\n#### Parameters\r\n\r\nIf a *Nonterminal* on the right-hand-side of a production needs to set a parameter, they supply it in an argument list.\r\nSupplying the name of the argument sets the parameter, prefixing the name with a question mark ('?) passes the current value of the parameter, and eliding the argument clears the parameter:\r\n\r\n```\r\nDeclaration[Yield] :\r\n\tHoistableDeclaration[?Yield]\r\n\tClassDeclaration[?Yield]\r\n\tLexicalDeclaration[In, ?Yield]\r\n```\r\n\r\nThe right-hand-side of a *Production* consists of one or more *Terminal* or *Nonterminal* symbols, a sentence of *Prose*, or an *Assertion*.\r\n\r\n#### Terminals\r\n\r\nA *Terminal* symbol can be one of the following:\r\n\r\n* A literal string of one or more characters enclosed in backticks ('\\`'). For example: `` `function` ``\r\n* A sequence of three backtick characters, which denotes a backtick token. For example: `` ``` ``\r\n* A unicode character literal enclosed in a leading less-than ('<') character and a trailing greater-than ('>') character. For example: `<TAB>`\r\n\r\n#### Nonterminals\r\n\r\nA *Nonterminal* symbol is an identifier, followed by an optional argument list, and an optional question mark ('?'). The question mark changes the cardinality of the *Nonterminal* from \"exactly one\" to \"zero or one\".\r\nThe identifier may optionally be enclosed in `|` characters, if it happens to collide with a keyword.\r\n\r\n#### Character Literals and Ranges\r\n\r\nCharacter literals may be specified using one of the following forms:\r\n\r\n* An abbreviation for a Unicode Code point, of the form `<NBSP>`\r\n* A Unicode code point, of the form `U+00A0`\r\n\r\nCharacter ranges may be specified using the `through` keyword:\r\n\r\n```\r\n    SourceCharacter but not one of `\"` or `\\` or U+0000 through U+001F\r\n```\r\n\r\n#### Prose\r\n\r\nA sentence of *Prose* is a single line with a leading greater-than ('>') character. For example: `> any Unicode code point`\r\n\r\n#### The `but not` Condition\r\n\r\nThe `but not` condition allows you to reference a production, excluding some part of that production. For example:\r\n\r\n```\r\nMultiLineNotAsteriskChar ::\r\n\tSourceCharacter but not `*`\r\n```\r\n\r\nHere, *MultiLineNotAsteriskChar* may contain any alternative from *SourceCharacter*, except the terminal `` `*` ``.\r\n\r\n#### The `one of` Condition\r\n\r\nYou can exclude multiple alternatives by including a list of symbols to exclude through the use of the `one of` keyphrase.\r\nEach entry in the list is separated by `or`:\r\n\r\n```\r\nMultiLineNotForwardSlashOrAsteriskChar ::\r\n\tSourceCharacter but not one of `/` or `*`\r\n```\r\n\r\n#### Assertions\r\n\r\nAn *Assertion* is a zero-width test that must evaluate successfully for the *Production* to be considered.\r\n*Assertions* are enclosed in a leading open bracket ('\\[') character and a trailing close-bracket ('\\]') character.\r\n\r\nThe possible assertions include:\r\n\r\n* The *empty assertion*, which matches exactly zero tokens: `[empty]`\r\n* The *lookahead assertion*, which verifies the next tokens in the stream: ``[lookahead != `function`]``\r\n* The *no-symbol-here assertion*, which verifies the next token is not the provided symbol: `[no LineTerminator here]`\r\n* The *lexical-goal assertion*, which states that the current lexical goal is the supplied *Nonterminal*: `[lexical goal InputElementRegExp]`\r\n* The *parameter assertion*, which states the supplied parameter to the current production is either set (using the plus ('+') character), or cleared (using the tilde ('~') character): `` [~Yield] `yield` ``\r\n* The *prose assertion*, which allows for arbitrary prose, mixed with terminals and nonterminals: ``[> prose text `terminal` prose text |NonTerminal| prose text]``\r\n\r\nA *lookahead assertion* has the following operators:\r\n\r\n* The `==` operator states the lookahead phrase is matched: ``[lookahead == `class`]``\r\n* The `!=` operator states the lookahead phrase is not matched: ``[lookahead != `function`]``\r\n* The `<-` operator states that any matching phrase in the provided set is matched: ``[lookahead <- { `public`, `private` }]``\r\n* The `<!` operator states that any matching phrase in the provided set is not matched: ``[lookahead <! { `{`, `function` }]``\r\n\r\n#### Linking\r\n\r\nDuring emit, `grammarkdown` implicitly adds a generated name for each *Production* and *Right-hand side* that can be used to\r\nlink directly to the production using a URI fragment. You can explicitly set the name for a production by tagging it with a custom link name:\r\n\r\n```\r\nDeclaration[Yield] :\r\n\tHoistableDeclaration[?Yield]       #declaration-hoistable\r\n\tClassDeclaration[?Yield]           #declaration-class\r\n\tLexicalDeclaration[In, ?Yield]     #declaration-lexical\r\n```\r\n\r\n#### Comments\r\n\r\nYou can also annotate your grammar with C-style single-line and multi-line comments.\r\n\r\n#### Examples\r\n\r\nFor comprehensive examples of `grammarkdown` syntax and output, you can review the following samples:\r\n\r\n* ECMA-262 version 2015 (ES6) Grammar\r\n  * [Plain-text](https://github.com/rbuckton/grammarkdown/blob/master/spec/es6.grammar)\r\n  * [HTML](https://rbuckton.github.io/grammarkdown/es6.html)\r\n* TypeScript 1.5 Supplemental Grammar\r\n  * [Plain-text](https://github.com/rbuckton/grammarkdown/blob/master/spec/typescript.grammar)\r\n  * [HTML](https://rbuckton.github.io/grammarkdown/typescript.html)\r\n\r\n## API\r\n\r\n`grammarkdown` has an API that can be consumed:\r\n\r\n```js\r\nvar grammarkdown = require(\"grammarkdown\")\r\n  , Grammar = grammarkdown.Grammar\r\n  , EmitFormat = grammarkdown.EmitFormat\r\n\r\nvar filename = \"...\";\r\nvar source = \"...\";\r\nvar output;\r\n\r\n// parse\r\nvar grammar = new Grammar(\r\n  [filename],\r\n  { format: EmitFormat.markdown },\r\n  function () { return source; });\r\n\r\n// bind (optional, bind happens automatically during check)\r\ngrammar.bind();\r\n\r\n// check (optional, check happens automatically during emit)\r\ngrammar.check();\r\n\r\n// emit\r\ngrammar.emit(undefined, function (file, text) { output = text; });\r\n\r\nconsole.log(output);\r\n```\r\n\r\n## Related\r\n\r\n* [ecmarkup](https://bterlson.github.io/ecmarkup)\r\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/rbuckton/grammarkdown.git"
  },
  "scripts": {
    "build": "gulp build",
    "prepublish": "gulp test",
    "test": "gulp test",
    "update-pages": "gulp publish"
  },
  "typings": "./out/lib/index.d.ts",
  "version": "1.0.8"
}
