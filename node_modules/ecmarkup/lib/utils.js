"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const jsdom = require("jsdom");
const chalk = require("chalk");
const emd = require("ecmarkdown");
const fs = require("fs");
/*@internal*/
function emdTextNode(spec, node) {
    // emd strips starting and ending spaces which we want to preserve
    const startSpace = node.textContent.match(/^\s*/)[0];
    const endSpace = node.textContent.match(/\s*$/)[0];
    const template = spec.doc.createElement('template');
    template.innerHTML = startSpace + emd.fragment(node.textContent) + endSpace;
    replaceTextNode(node, template.content);
}
exports.emdTextNode = emdTextNode;
/*@internal*/
function htmlToDom(html) {
    return new jsdom.JSDOM(html, { includeNodeLocations: true });
}
exports.htmlToDom = htmlToDom;
/*@internal*/
function domWalkBackward(root, cb) {
    const childNodes = root.childNodes;
    const childLen = childNodes.length;
    for (let i = childLen - 1; i >= 0; i--) {
        const node = childNodes[i];
        if (node.nodeType !== 1)
            continue;
        const cont = cb(node);
        if (cont === false)
            continue;
        domWalkBackward(node, cb);
    }
}
exports.domWalkBackward = domWalkBackward;
/*@internal*/
function replaceTextNode(node, frag) {
    // Append all the nodes
    const parent = node.parentNode;
    if (!parent)
        return [];
    const newXrefNodes = Array.from(frag.querySelectorAll('EMU-XREF'));
    const first = frag.childNodes[0];
    if (first.nodeType === 3) {
        node.textContent = first.textContent;
        frag.removeChild(first);
    }
    else {
        // set it to empty because we don't want to break iteration
        // (I think it should work to delete it... investigate possible jsdom bug)  
        node.textContent = '';
    }
    parent.insertBefore(frag, node.nextSibling);
    return newXrefNodes;
}
exports.replaceTextNode = replaceTextNode;
/*@internal*/
function logVerbose(str) {
    let dateString = (new Date()).toISOString();
    console.log(chalk.gray('[' + dateString + '] ') + str);
}
exports.logVerbose = logVerbose;
/*@internal*/
function logWarning(str) {
    let dateString = (new Date()).toISOString();
    console.log(chalk.gray('[' + dateString + '] ') + chalk.red('Warning: ' + str));
}
exports.logWarning = logWarning;
/*@internal*/
function shouldInline(node) {
    let parent = node.parentNode;
    if (!parent)
        return false;
    while (parent && parent.parentNode &&
        (parent.nodeName === 'EMU-GRAMMAR' || parent.nodeName === 'EMU-IMPORT' || parent.nodeName === 'INS' || parent.nodeName === 'DEL')) {
        parent = parent.parentNode;
    }
    return ['EMU-ANNEX', 'EMU-CLAUSE', 'EMU-INTRO', 'EMU-NOTE', 'BODY'].indexOf(parent.nodeName) === -1;
}
exports.shouldInline = shouldInline;
/*@internal*/
function readFile(file) {
    return new Promise((resolve, reject) => {
        fs.readFile(file, "utf8", (err, data) => err ? reject(err) : resolve(data));
    });
}
exports.readFile = readFile;
/*@internal*/
function writeFile(file, content) {
    return new Promise((resolve, reject) => {
        fs.writeFile(file, content, { encoding: "utf8" }, err => err ? reject(err) : resolve());
    });
}
exports.writeFile = writeFile;
/*@internal*/
function copyFile(src, dest) {
    return __awaiter(this, void 0, void 0, function* () {
        const content = yield readFile(src);
        yield writeFile(dest, content);
    });
}
exports.copyFile = copyFile;
