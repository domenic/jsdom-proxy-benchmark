"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const args = require('./args').parse();
// requires after arg checking to avoid expensive load times
const ecmarkup = require("./ecmarkup");
const fs = require("fs");
const utils = require("./utils");
const debounce = require("promise-debounce");
var __awaiter = require('./awaiter');
// back compat to old argument names
if (args.css) {
    args.cssOut = args.css;
}
if (args.js) {
    args.jsOut = args.js;
}
const watching = new Map();
const build = debounce(function build() {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const spec = yield ecmarkup.build(args.infile, utils.readFile, args);
            const pending = [];
            if (args.biblio) {
                if (args.verbose) {
                    utils.logVerbose('Writing biblio file to ' + args.biblio);
                }
                pending.push(utils.writeFile(args.biblio, JSON.stringify(spec.exportBiblio())));
            }
            if (args.outfile) {
                if (args.verbose) {
                    utils.logVerbose('Writing output to ' + args.outfile);
                }
                pending.push(utils.writeFile(args.outfile, spec.toHTML()));
            }
            else {
                process.stdout.write(spec.toHTML());
            }
            yield Promise.all(pending);
            if (args.watch) {
                const toWatch = new Set(spec.imports.map(i => i.importLocation).concat(args.infile));
                // remove any files that we're no longer watching
                for (const [file, watcher] of watching) {
                    if (!toWatch.has(file)) {
                        watcher.close();
                        watching.delete(file);
                    }
                }
                // watch any new files
                for (const file of toWatch) {
                    if (!watching.has(file)) {
                        watching.set(file, fs.watch(file, build));
                    }
                }
            }
        }
        catch (e) {
            process.stderr.write(e.stack);
        }
    });
});
build().catch(e => {
    console.error(e);
    process.exit(1);
});
