"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const fs = require("fs");
const Path = require("path");
const yaml = require("js-yaml");
const utils = require("./utils");
const hljs = require("highlight.js");
const Import_1 = require("./Import");
const H1_1 = require("./H1");
const Clause_1 = require("./Clause");
const clauseNums_1 = require("./clauseNums");
const Algorithm_1 = require("./Algorithm");
const Dfn_1 = require("./Dfn");
const Example_1 = require("./Example");
const Figure_1 = require("./Figure");
const Note_1 = require("./Note");
const Toc_1 = require("./Toc");
const Menu_1 = require("./Menu");
const Production_1 = require("./Production");
const NonTerminal_1 = require("./NonTerminal");
const ProdRef_1 = require("./ProdRef");
const Grammar_1 = require("./Grammar");
const Xref_1 = require("./Xref");
const Eqn_1 = require("./Eqn");
const Biblio_1 = require("./Biblio");
const autolinker_1 = require("./autolinker");
const prex_1 = require("prex");
var __awaiter = require('./awaiter');
const DRAFT_DATE_FORMAT = { year: 'numeric', month: 'long', day: 'numeric', timeZone: 'UTC' };
const STANDARD_DATE_FORMAT = { year: 'numeric', month: 'long', timeZone: 'UTC' };
const NO_EMD = new Set(['PRE', 'CODE', 'EMU-PRODUCTION', 'EMU-ALG', 'EMU-GRAMMAR', 'EMU-EQN']);
var builders = [
    Clause_1.default,
    H1_1.default,
    Algorithm_1.default,
    Xref_1.default,
    Dfn_1.default,
    Eqn_1.default,
    Grammar_1.default,
    Production_1.default,
    Example_1.default,
    Figure_1.default,
    NonTerminal_1.default,
    ProdRef_1.default,
    Note_1.default
];
const visitorMap = builders.reduce((map, T) => {
    T.elements.forEach(e => map[e] = T);
    return map;
}, {});
/*@internal*/
class Spec {
    constructor(rootPath, fetch, dom, opts, sourceText, token = prex_1.CancellationToken.none) {
        opts = opts || {};
        this.spec = this;
        this.opts = {};
        this.rootPath = rootPath;
        this.rootDir = Path.dirname(this.rootPath);
        this.sourceText = sourceText;
        this.doc = dom.window.document;
        this.dom = dom;
        this._fetch = fetch;
        this.subclauses = [];
        this.imports = [];
        this.node = this.doc.body;
        this.cancellationToken = token;
        this._figureCounts = {
            table: 0,
            figure: 0
        };
        this._textNodes = {};
        this.processMetadata();
        Object.assign(this.opts, opts);
        if (!this.opts.hasOwnProperty('status')) {
            this.opts.status = 'proposal';
        }
        if (!this.opts.hasOwnProperty('toc')) {
            this.opts.toc = true;
        }
        if (!this.opts.hasOwnProperty('copyright')) {
            this.opts.copyright = true;
        }
        if (!this.opts.date) {
            this.opts.date = new Date();
        }
        if (this.opts.stage != undefined) {
            this.opts.stage = String(this.opts.stage);
        }
        if (!this.opts.location) {
            this.opts.location = '<no location>';
        }
        this.namespace = this.opts.location;
        this.biblio = new Biblio_1.default(this.opts.location);
    }
    fetch(file) {
        return this._fetch(file, this.cancellationToken);
    }
    build() {
        return __awaiter(this, void 0, void 0, function* () {
            /*
            The Ecmarkup build process proceeds as follows:
            
            1. Load biblios, making xrefs and auto-linking from external specs work
            2. Load imports by recursively inlining the import files' content into the emu-import element
            3. Generate boilerplate text
            4. Do a walk of the DOM visting elements and text nodes. Text nodes are replaced by text and HTML nodes depending
               on content. Elements are built by delegating to builders. Builders work by modifying the DOM ahead of them so
               the new elements they make are visited during the walk. Elements added behind the current iteration must be
               handled specially (eg. see static exit method of clause). Xref, nt, and prodref's are collected for linking
               in the next step.
            5. Linking. After the DOM walk we have a complete picture of all the symbols in the document so we proceed to link
               the various xrefs to the proper place.
            6. Adding charset, highlighting code, etc.
            7. Add CSS & JS dependencies.
            */
            this._log('Loading biblios...');
            yield this.loadES6Biblio();
            yield this.loadBiblios();
            this._log('Loading imports...');
            yield this.loadImports();
            this._log('Building boilerplate...');
            this.buildBoilerplate();
            this._log('Walking document, building various elements...');
            const context = {
                spec: this,
                node: this.doc.body,
                importStack: [],
                clauseStack: [],
                tagStack: [],
                clauseNumberer: clauseNums_1.default(),
                inNoAutolink: false,
                inAlg: false,
                inNoEmd: false,
                startEmd: null,
                currentId: null
            };
            this._xrefs = [];
            this._ntRefs = [];
            this._prodRefs = [];
            const document = this.doc;
            const walker = document.createTreeWalker(document.body, 1 | 4 /* elements and text nodes */);
            walk(walker, context);
            this.autolink();
            this._log('Linking xrefs...');
            this._xrefs.forEach(xref => xref.build());
            this._log('Linking non-terminal references...');
            this._ntRefs.forEach(nt => nt.build());
            this._log('Linking production references...');
            this._prodRefs.forEach(prod => prod.build());
            this._log('Building reference graph...');
            this.buildReferenceGraph();
            this.highlightCode();
            this.setCharset();
            this.setFirstH1Class();
            this.buildSpecWrapper();
            if (this.opts.toc) {
                this._log('Building table of contents...');
                let toc;
                if (this.opts.oldToc) {
                    toc = new Toc_1.default(this);
                }
                else {
                    toc = new Menu_1.default(this);
                }
                toc.build();
            }
            yield this.buildAssets();
            return this;
        });
    }
    toHTML() {
        return '<!doctype html>\n' + this.doc.documentElement.innerHTML;
    }
    buildReferenceGraph() {
        let counter = 0;
        this._xrefs.forEach(xref => {
            let entry = xref.entry;
            if (!entry || entry.namespace === "global")
                return;
            if (!entry.id && entry.refId) {
                entry = this.spec.biblio.byId(entry.refId);
            }
            if (!xref.id) {
                const id = `_ref_${counter++}`;
                xref.node.setAttribute('id', id);
                xref.id = id;
            }
            entry.referencingIds.push(xref.id);
        });
        this._ntRefs.forEach(prod => {
            const entry = prod.entry;
            if (!entry || entry.namespace === "global")
                return;
            // if this is the defining nt of an emu-production, don't create a ref
            if (prod.node.parentNode.nodeName === "EMU-PRODUCTION")
                return;
            const id = `_ref_${counter++}`;
            prod.node.setAttribute('id', id);
            entry.referencingIds.push(id);
        });
    }
    buildAssets() {
        return __awaiter(this, void 0, void 0, function* () {
            const jsContents = yield concatJs();
            const cssContents = yield utils.readFile(path.join(__dirname, '../css/elements.css'));
            if (this.opts.jsOut) {
                this._log(`Writing js file to ${this.opts.jsOut}...`);
                yield utils.writeFile(this.opts.jsOut, jsContents);
            }
            if (this.opts.cssOut) {
                this._log(`Writing css file to ${this.opts.cssOut}...`);
                yield utils.writeFile(this.opts.cssOut, cssContents);
            }
            if (this.opts.assets === 'none')
                return;
            // back-compat: if we already have a link to this script or css, bail out
            let skipJs = false, skipCss = false, outDir;
            if (this.opts.outfile) {
                outDir = Path.dirname(this.opts.outfile);
            }
            else {
                outDir = process.cwd();
            }
            if (this.opts.jsOut) {
                const scripts = this.doc.querySelectorAll('script');
                for (let i = 0; i < scripts.length; i++) {
                    const script = scripts[i];
                    const src = script.getAttribute('src');
                    if (src && Path.normalize(Path.join(outDir, src)) === Path.normalize(this.opts.jsOut)) {
                        this._log(`Found existing js link to ${src}, skipping inlining...`);
                        skipJs = true;
                    }
                }
            }
            if (this.opts.cssOut) {
                const links = this.doc.querySelectorAll('link[rel=stylesheet]');
                for (let i = 0; i < links.length; i++) {
                    const link = links[i];
                    const href = link.getAttribute('href');
                    if (href && Path.normalize(Path.join(outDir, href)) === Path.normalize(this.opts.cssOut)) {
                        this._log(`Found existing css link to ${href}, skipping inlining...`);
                        skipCss = true;
                    }
                }
            }
            if (!skipJs) {
                this._log('Inlining JavaScript assets...');
                const script = this.doc.createElement('script');
                script.textContent = jsContents;
                this.doc.head.appendChild(script);
            }
            if (!skipCss) {
                this._log('Inlining CSS assets...');
                const style = this.doc.createElement('style');
                style.textContent = cssContents;
                this.doc.head.appendChild(style);
            }
        });
    }
    buildSpecWrapper() {
        const elements = this.doc.body.childNodes;
        const wrapper = this.doc.createElement('div');
        wrapper.id = 'spec-container';
        while (elements.length > 0) {
            wrapper.appendChild(elements[0]);
        }
        this.doc.body.appendChild(wrapper);
    }
    processMetadata() {
        const block = this.doc.querySelector('pre.metadata');
        if (!block || !block.parentNode) {
            return;
        }
        let data;
        try {
            data = yaml.safeLoad(block.textContent);
        }
        catch (e) {
            utils.logWarning('metadata block failed to parse');
            return;
        }
        finally {
            block.parentNode.removeChild(block);
        }
        Object.assign(this.opts, data);
    }
    loadES6Biblio() {
        return __awaiter(this, void 0, void 0, function* () {
            this.cancellationToken.throwIfCancellationRequested();
            yield this.loadBiblio(path.join(__dirname, "../es6biblio.json"));
        });
    }
    loadBiblios() {
        return __awaiter(this, void 0, void 0, function* () {
            this.cancellationToken.throwIfCancellationRequested();
            yield Promise.all(Array.from(this.doc.querySelectorAll('emu-biblio'))
                .map(biblio => this.loadBiblio(path.join(this.rootDir, biblio.getAttribute('href')))));
        });
    }
    loadBiblio(file) {
        return __awaiter(this, void 0, void 0, function* () {
            const contents = yield this.fetch(file);
            this.biblio.addExternalBiblio(JSON.parse(contents));
        });
    }
    loadImports() {
        return __awaiter(this, void 0, void 0, function* () {
            yield loadImports(this, this.spec.doc.body, this.rootDir);
        });
    }
    exportBiblio() {
        if (!this.opts.location) {
            utils.logWarning('No spec location specified. Biblio not generated. Try --location or setting the location in the document\'s metadata block.');
            return {};
        }
        const biblio = {};
        biblio[this.opts.location] = this.biblio.toJSON();
        return biblio;
    }
    highlightCode() {
        this._log('Highlighting syntax...');
        const codes = this.doc.querySelectorAll('pre code');
        for (let i = 0; i < codes.length; i++) {
            const classAttr = codes[i].getAttribute('class');
            if (!classAttr)
                continue;
            const lang = classAttr.replace(/lang(uage)?\-/, '');
            let input = codes[i].textContent;
            // remove leading and trailing blank lines
            input = input.replace(/^(\s*[\r\n])+|([\r\n]\s*)+$/g, '');
            // remove base inden based on indent of first non-blank line
            const baseIndent = input.match(/^\s*/) || '';
            const baseIndentRe = new RegExp('^' + baseIndent, 'gm');
            input = input.replace(baseIndentRe, '');
            const result = hljs.highlight(lang, input);
            codes[i].innerHTML = result.value;
            codes[i].setAttribute('class', classAttr + ' hljs');
        }
    }
    // if there is no text between body start and the first H1, the first H1 is given a class of "first"
    setFirstH1Class() {
        const document = this.spec.doc;
        const walker = document.createTreeWalker(document.body, 1 | 4 /* elements and text nodes */);
        let node = walker.currentNode;
        while (node) {
            if (node.nodeType === 3 && node.textContent.trim().length > 0) {
                return;
            }
            if (walker.currentNode.nodeType === 1 && walker.currentNode.nodeName === 'H1') {
                node.classList.add('first');
                return;
            }
            node = walker.nextNode();
        }
    }
    buildBoilerplate() {
        this.cancellationToken.throwIfCancellationRequested();
        const status = this.opts.status;
        const version = this.opts.version;
        const title = this.opts.title;
        const shortname = this.opts.shortname;
        const stage = this.opts.stage;
        if (this.opts.copyright) {
            if (status !== 'draft' && status !== 'standard' && !this.opts.contributors) {
                utils.logWarning('Contributors not specified, skipping copyright boilerplate. Specify contributors in your frontmatter metadata.');
            }
            else {
                this.buildCopyrightBoilerplate();
            }
        }
        // no title boilerplate generated if title not specified
        if (!title)
            return;
        // title
        if (title && !this._updateBySelector('title', title)) {
            const titleElem = this.doc.createElement('title');
            titleElem.innerHTML = title;
            this.doc.head.appendChild(titleElem);
            const h1 = this.doc.createElement('h1');
            h1.setAttribute('class', 'title');
            h1.innerHTML = title;
            this.doc.body.insertBefore(h1, this.doc.body.firstChild);
        }
        // version string, ala 6th Edition July 2016 or Draft 10 / September 26, 2015
        let versionText = '';
        let omitShortname = false;
        if (version) {
            versionText += version + ' / ';
        }
        else if (status === 'proposal' && stage) {
            versionText += 'Stage ' + stage + ' Draft / ';
        }
        else if (shortname && status === 'draft') {
            versionText += 'Draft ' + shortname + ' / ';
            omitShortname = true;
        }
        else {
            return;
        }
        const defaultDateFormat = status === 'standard' ? STANDARD_DATE_FORMAT : DRAFT_DATE_FORMAT;
        const date = new Intl.DateTimeFormat('en-US', defaultDateFormat).format(this.opts.date);
        versionText += date;
        if (!this._updateBySelector('h1.version', versionText)) {
            const h1 = this.doc.createElement('h1');
            h1.setAttribute('class', 'version');
            h1.innerHTML = versionText;
            this.doc.body.insertBefore(h1, this.doc.body.firstChild);
        }
        // shortname and status, ala 'Draft ECMA-262
        if (shortname && !omitShortname) {
            const shortnameText = status.charAt(0).toUpperCase() + status.slice(1) + ' ' + shortname;
            if (!this._updateBySelector('h1.shortname', shortnameText)) {
                const h1 = this.doc.createElement('h1');
                h1.setAttribute('class', 'shortname');
                h1.innerHTML = shortnameText;
                this.doc.body.insertBefore(h1, this.doc.body.firstChild);
            }
        }
    }
    buildCopyrightBoilerplate() {
        let copyright;
        let address;
        if (this.opts.status === 'draft') {
            copyright = getBoilerplate('draft-copyright');
            address = getBoilerplate('address');
        }
        else if (this.opts.status === 'standard') {
            copyright = getBoilerplate('standard-copyright');
            address = getBoilerplate('address');
        }
        else {
            copyright = getBoilerplate('proposal-copyright');
            address = '';
        }
        copyright = copyright.replace(/!YEAR!/g, "" + this.opts.date.getFullYear());
        if (this.opts.contributors) {
            copyright = copyright.replace(/!CONTRIBUTORS!/g, this.opts.contributors);
        }
        const softwareLicense = getBoilerplate('software-license');
        let copyrightClause = this.doc.querySelector('.copyright-and-software-license');
        if (!copyrightClause) {
            let last;
            utils.domWalkBackward(this.doc.body, node => {
                if (last)
                    return false;
                if (node.nodeName === 'EMU-CLAUSE' || node.nodeName === 'EMU-ANNEX') {
                    last = node;
                    return false;
                }
            });
            copyrightClause = this.doc.createElement('emu-annex');
            copyrightClause.setAttribute('id', 'sec-copyright-and-software-license');
            if (last && last.parentNode) {
                last.parentNode.insertBefore(copyrightClause, last.nextSibling);
            }
            else {
                this.doc.body.appendChild(copyrightClause);
            }
        }
        copyrightClause.innerHTML = `
      <h1>Copyright &amp; Software License</h1>
      ${address}
      <h2>Copyright Notice</h2>
      ${copyright.replace('!YEAR!', "" + this.opts.date.getFullYear())}
      <h2>Software License</h2>
      ${softwareLicense}
    `;
    }
    autolink() {
        this._log('Autolinking terms and abstract ops...');
        const document = this.doc;
        let namespaces = Object.keys(this._textNodes);
        for (let i = 0; i < namespaces.length; i++) {
            let namespace = namespaces[i];
            const [replacer, autolinkmap] = autolinker_1.replacerForNamespace(namespace, this.biblio);
            let nodes = this._textNodes[namespace];
            for (let j = 0; j < nodes.length; j++) {
                const { node, clause, inAlg, currentId } = nodes[j];
                autolinker_1.autolink(node, replacer, autolinkmap, clause, currentId, inAlg);
            }
        }
    }
    setCharset() {
        let current = this.spec.doc.querySelector('meta[charset]');
        if (!current) {
            current = this.spec.doc.createElement('meta');
            this.spec.doc.head.insertBefore(current, this.spec.doc.head.firstChild);
        }
        current.setAttribute('charset', 'utf-8');
    }
    /*@internal*/
    _log(str) {
        if (!this.opts.verbose)
            return;
        utils.logVerbose(str);
    }
    _updateBySelector(selector, contents) {
        const elem = this.doc.querySelector(selector);
        if (elem && elem.textContent.trim().length > 0) {
            return true;
        }
        if (elem) {
            elem.innerHTML = contents;
            return true;
        }
        return false;
    }
}
exports.default = Spec;
;
function assign(target, source) {
    Object.keys(source).forEach(function (k) {
        target[k] = source[k];
    });
}
function getBoilerplate(file) {
    return fs.readFileSync(Path.join(__dirname, '../boilerplate', file + '.html'), 'utf8');
}
function loadImports(spec, rootElement, rootPath) {
    return __awaiter(this, void 0, void 0, function* () {
        let imports = rootElement.querySelectorAll('EMU-IMPORT');
        for (let i = 0; i < imports.length; i++) {
            let node = imports[i];
            let imp = yield Import_1.default.build(spec, node, rootPath);
            yield loadImports(spec, node, imp.relativeRoot);
        }
    });
}
function walk(walker, context) {
    // When we set either of these states we need to know to unset when we leave the element.
    let changedInNoAutolink = false;
    let changedInNoEmd = false;
    const { spec, node } = context;
    context.node = walker.currentNode;
    context.tagStack.push(context.node);
    if (context.node === context.startEmd) {
        context.startEmd = null;
        context.inNoEmd = false;
    }
    if (context.node.nodeType === 3) {
        // walked to a text node
        if (context.node.textContent.trim().length === 0)
            return; // skip empty nodes; nothing to do!
        if (!context.inNoEmd) {
            // new nodes as a result of emd processing should be skipped
            context.inNoEmd = true;
            // inNoEmd is set to true when we walk to this node 
            let node = context.node;
            while (node && !node.nextSibling) {
                node = node.parentNode;
            }
            if (node) {
                context.startEmd = node.nextSibling;
            }
            // else, inNoEmd will just continue to the end of the file
            utils.emdTextNode(context.spec, context.node);
        }
        if (!context.inNoAutolink) {
            // stuff the text nodes into an array for auto-linking with later
            // (since we can't autolink at this point without knowing the biblio).
            const clause = context.clauseStack[context.clauseStack.length - 1] || context.spec;
            const namespace = clause ? clause.namespace : context.spec.namespace;
            context.spec._textNodes[namespace] = context.spec._textNodes[namespace] || [];
            context.spec._textNodes[namespace].push({
                node: context.node,
                clause: clause,
                inAlg: context.inAlg,
                currentId: context.currentId
            });
        }
        return;
    }
    // context.node is an HTMLElement (node type 1)
    // handle oldids
    let oldids = context.node.getAttribute('oldids');
    if (oldids) {
        if (!context.node.children) {
            throw new Error("oldids found on unsupported element: " + context.node.nodeName);
        }
        oldids.split(/,/g).map(s => s.trim()).forEach(oid => {
            let s = spec.doc.createElement('span');
            s.setAttribute('id', oid);
            context.node.insertBefore(s, context.node.children[0]);
        });
    }
    let parentId = context.currentId;
    if (context.node.hasAttribute('id')) {
        context.currentId = context.node.getAttribute('id');
    }
    // See if we should stop auto-linking here.
    if (autolinker_1.NO_CLAUSE_AUTOLINK.has(context.node.nodeName) && !context.inNoAutolink) {
        context.inNoAutolink = true;
        changedInNoAutolink = true;
    }
    // check if entering a noEmd tag
    if (NO_EMD.has(context.node.nodeName) && !context.inNoEmd) {
        context.inNoEmd = true;
        changedInNoEmd = true;
    }
    const visitor = visitorMap[context.node.nodeName];
    if (visitor)
        visitor.enter(context);
    const firstChild = walker.firstChild();
    if (firstChild) {
        while (true) {
            walk(walker, context);
            const next = walker.nextSibling();
            if (!next)
                break;
        }
        walker.parentNode();
        context.node = walker.currentNode;
    }
    if (visitor)
        visitor.exit(context);
    if (changedInNoAutolink)
        context.inNoAutolink = false;
    if (changedInNoEmd)
        context.inNoEmd = false;
    context.currentId = parentId;
    context.tagStack.pop();
}
const jsDependencies = ['menu.js', 'findLocalReferences.js'];
function concatJs() {
    return __awaiter(this, void 0, void 0, function* () {
        const dependencies = yield Promise.all(jsDependencies
            .map(dependency => utils.readFile(path.join(__dirname, "../js/" + dependency))));
        return dependencies.reduce((js, dependency) => js + dependency, '');
    });
}
