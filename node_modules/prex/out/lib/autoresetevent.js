/*! *****************************************************************************
Copyright (c) Microsoft Corporation.
Licensed under the Apache License, Version 2.0.

See LICENSE file in the project root for details.
***************************************************************************** */
"use strict";
const list_1 = require("./list");
const cancellation_1 = require("./cancellation");
const utils_1 = require("./utils");
/**
 * Asynchronously notifies one or more waiting Promises that an event has occurred.
 */
class AutoResetEvent {
    /**
     * Initializes a new instance of the AutoResetEvent class.
     *
     * @param initialState A value indicating whether to set the initial state to signaled.
     */
    constructor(initialState) {
        this._waiters = new list_1.LinkedList();
        if (utils_1.isMissing(initialState))
            initialState = false;
        if (!utils_1.isBoolean(initialState))
            throw new TypeError("Boolean expected: initialState.");
        this._signaled = initialState;
    }
    /**
     * Sets the state of the event to signaled, resolving one or more waiting Promises.
     * The event is then automatically reset.
     */
    set() {
        if (!this._signaled) {
            this._signaled = true;
            if (this._waiters.size > 0) {
                for (const waiter of this._waiters.drain()) {
                    waiter();
                }
                this._signaled = false;
            }
        }
    }
    /**
     * Sets the state of the event to nonsignaled, causing asynchronous operations to pause.
     */
    reset() {
        this._signaled = false;
    }
    /**
     * Asynchronously waits for the event to become signaled.
     *
     * @param token A CancellationToken used to cancel the request.
     */
    wait(token) {
        return new Promise((resolve, reject) => {
            if (utils_1.isMissing(token))
                token = cancellation_1.CancellationToken.none;
            if (!utils_1.isInstance(token, cancellation_1.CancellationToken))
                throw new TypeError("CancellationToken expected: token.");
            token.throwIfCancellationRequested();
            if (this._signaled) {
                resolve();
                this._signaled = false;
                return;
            }
            const node = this._waiters.push(() => {
                registration.unregister();
                resolve();
            });
            const registration = token.register(() => {
                node.list.deleteNode(node);
                reject(new cancellation_1.CancelError());
            });
        });
    }
}
exports.AutoResetEvent = AutoResetEvent;

//# sourceMappingURL=autoresetevent.js.map
