/*! *****************************************************************************
Copyright (c) Microsoft Corporation.
Licensed under the Apache License, Version 2.0.

See LICENSE file in the project root for details.
***************************************************************************** */
export declare class LinkedListNode<T> {
    value: T;
    constructor(value?: T);
    readonly list: LinkedList<T>;
    readonly previous: LinkedListNode<T>;
    readonly next: LinkedListNode<T>;
}
export declare class LinkedList<T> {
    private _head;
    private _size;
    constructor(iterable?: Iterable<T>);
    readonly first: LinkedListNode<T>;
    readonly last: LinkedListNode<T>;
    readonly size: number;
    values(): IterableIterator<T>;
    nodes(): IterableIterator<LinkedListNode<T>>;
    drain(): IterableIterator<T>;
    find(value: T): LinkedListNode<T>;
    findLast(value: T): LinkedListNode<T>;
    has(value: T): boolean;
    insertBefore(node: LinkedListNode<T>, value: T): LinkedListNode<T>;
    insertNodeBefore(node: LinkedListNode<T>, newNode: LinkedListNode<T>): void;
    insertAfter(node: LinkedListNode<T>, value: T): LinkedListNode<T>;
    insertNodeAfter(node: LinkedListNode<T>, newNode: LinkedListNode<T>): void;
    push(value?: T): LinkedListNode<T>;
    pushNode(newNode: LinkedListNode<T>): void;
    pop(): T;
    popNode(): LinkedListNode<T>;
    shift(): T;
    shiftNode(): LinkedListNode<T>;
    unshift(value?: T): LinkedListNode<T>;
    unshiftNode(newNode: LinkedListNode<T>): void;
    delete(value: T): boolean;
    deleteNode(node: LinkedListNode<T>): boolean;
    deleteAll(predicate: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => boolean, thisArg?: any): number;
    clear(): void;
    forEach(callback: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => void, thisArg?: any): void;
    private _deleteNode(node);
    private _insertNode(adjacentNode, newNode, position);
}
export interface LinkedList<T> {
    [Symbol.iterator](): Iterator<T>;
}
