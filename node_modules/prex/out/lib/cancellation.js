/*! *****************************************************************************
Copyright (c) Microsoft Corporation.
Licensed under the Apache License, Version 2.0.

See LICENSE file in the project root for details.
***************************************************************************** */
"use strict";
const list_1 = require("./list");
const utils_1 = require("./utils");
/**
 * Signals a CancellationToken that it should be canceled.
 */
class CancellationTokenSource {
    /**
     * Initializes a new instance of a CancellationTokenSource.
     *
     * @param linkedTokens An optional iterable of tokens to which to link this source.
     */
    constructor(linkedTokens) {
        this._callbacks = undefined;
        this._linkingRegistrations = undefined;
        this._token = undefined;
        this._state = "open";
        if (!utils_1.isIterable(linkedTokens, /*optional*/ true))
            throw new TypeError("Object not iterable: linkedTokens.");
        if (linkedTokens) {
            for (const linkedToken of linkedTokens) {
                if (!utils_1.isInstance(linkedToken, CancellationToken))
                    throw new TypeError("CancellationToken expected.");
                if (linkedToken.cancellationRequested) {
                    this._state = "cancellationRequested";
                    this._unlink();
                    break;
                }
                else if (linkedToken.canBeCanceled) {
                    if (this._linkingRegistrations === undefined) {
                        this._linkingRegistrations = [];
                    }
                    this._linkingRegistrations.push(linkedToken.register(() => this.cancel()));
                }
            }
        }
    }
    /**
     * Gets a CancellationToken linked to this source.
     */
    get token() {
        if (this._token === undefined) {
            this._token = new CancellationToken(this);
        }
        return this._token;
    }
    /**
     * Gets a value indicating whether cancellation has been requested.
     */
    get cancellationRequested() {
        return this._state === "cancellationRequested";
    }
    /**
     * Gets a value indicating whether the source can be canceled.
     */
    get canBeCanceled() {
        return this._state !== "closed";
    }
    /**
     * Cancels the source, returning a Promise that is settled when cancellation has completed.
     * Any registered callbacks are executed in a later turn. If any callback raises an exception,
     * the first such exception can be observed by awaiting the return value of this method.
     */
    cancel() {
        return new Promise((resolve, reject) => {
            if (this._state !== "open") {
                resolve();
                return;
            }
            this._state = "cancellationRequested";
            this._unlink();
            const callbacks = this._callbacks;
            this._callbacks = undefined;
            if (callbacks && callbacks.size > 0) {
                const pendingOperations = [];
                for (const callback of callbacks) {
                    pendingOperations.push(this._executeCallback(callback));
                }
                // await all pending operations
                Promise.all(pendingOperations).then(() => resolve(), reject);
                return;
            }
            resolve();
        });
    }
    /**
     * Closes the source, preventing the possibility of future cancellation.
     */
    close() {
        if (this._state !== "open") {
            return;
        }
        this._state = "closed";
        this._unlink();
        const callbacks = this._callbacks;
        this._callbacks = undefined;
        if (callbacks !== undefined) {
            // The registration for each callback holds onto the node, the node holds onto the
            // list, and the list holds all other nodes and callbacks. By clearing the list, the
            // GC can collect any otherwise unreachable nodes.
            callbacks.clear();
        }
    }
    /**
     * Registers a callback to execute when cancellation has been requested. If cancellation has
     * already been requested, the callback is executed immediately.
     *
     * @param callback The callback to register.
     */
    register(callback) {
        if (!utils_1.isFunction(callback))
            throw new TypeError("Function expected: callback.");
        if (this._state === "requested") {
            callback();
        }
        if (this._state !== "open") {
            return emptyRegistration;
        }
        if (this._callbacks === undefined) {
            this._callbacks = new list_1.LinkedList();
        }
        const node = this._callbacks.push(() => {
            if (node.list) {
                node.list.deleteNode(node);
                callback();
            }
        });
        const registration = {
            unregister() {
                // When the callback is unregistered, remove the node from its list.
                if (node.list) {
                    node.list.deleteNode(node);
                }
            }
        };
        return registration;
    }
    /**
     * Executes the provided callback in a later turn.
     *
     * @param callback The callback to execute.
     */
    _executeCallback(callback) {
        return Promise.resolve().then(() => {
            callback();
        });
    }
    /**
     * Unlinks the source from any linked tokens.
     */
    _unlink() {
        const linkingRegistrations = this._linkingRegistrations;
        this._linkingRegistrations = undefined;
        if (linkingRegistrations !== undefined) {
            for (const linkingRegistration of linkingRegistrations) {
                linkingRegistration.unregister();
            }
        }
    }
}
exports.CancellationTokenSource = CancellationTokenSource;
// A source that cannot be canceled.
const closedSource = new CancellationTokenSource();
closedSource.close();
// A source that is already canceled.
const canceledSource = new CancellationTokenSource();
canceledSource.cancel();
/**
 * Propagates notifications that operations should be canceled.
 */
class CancellationToken {
    constructor(source) {
        if (utils_1.isMissing(source)) {
            this._source = closedSource;
        }
        else if (utils_1.isBoolean(source)) {
            this._source = source ? canceledSource : closedSource;
        }
        else {
            if (!utils_1.isInstance(source, CancellationTokenSource))
                throw new TypeError("CancellationTokenSource expected: source.");
            this._source = source;
        }
        Object.freeze(this);
    }
    /**
     * Gets a value indicating whether cancellation has been requested.
     */
    get cancellationRequested() {
        return this._source.cancellationRequested;
    }
    /**
     * Gets a value indicating whether the underlying source can be canceled.
     */
    get canBeCanceled() {
        return this._source.canBeCanceled;
    }
    /**
     * Throws a CancelError if cancellation has been requested.
     */
    throwIfCancellationRequested() {
        if (this.cancellationRequested) {
            throw new CancelError();
        }
    }
    /**
     * Registers a callback to execute when cancellation is requested.
     *
     * @param callback The callback to register.
     */
    register(callback) {
        return this._source.register(callback);
    }
}
/**
 * A token which will never be canceled.
 */
CancellationToken.none = new CancellationToken(/*canceled*/ false);
/**
 * A token that is already canceled.
 */
CancellationToken.canceled = new CancellationToken(/*canceled*/ true);
exports.CancellationToken = CancellationToken;
/**
 * An error thrown when an operation is canceled.
 */
class CancelError extends Error {
    constructor(message) {
        super(message || "Operation was canceled");
    }
}
exports.CancelError = CancelError;
CancelError.prototype.name = "CancelError";
const emptyRegistration = Object.create({ unregister() { } });

//# sourceMappingURL=cancellation.js.map
