/*! *****************************************************************************
Copyright (c) Microsoft Corporation.
Licensed under the Apache License, Version 2.0.

See LICENSE file in the project root for details.
***************************************************************************** */
/**
 * Signals a CancellationToken that it should be canceled.
 */
export declare class CancellationTokenSource {
    private _callbacks;
    private _linkingRegistrations;
    private _token;
    private _state;
    /**
     * Initializes a new instance of a CancellationTokenSource.
     *
     * @param linkedTokens An optional iterable of tokens to which to link this source.
     */
    constructor(linkedTokens?: Iterable<CancellationToken>);
    /**
     * Gets a CancellationToken linked to this source.
     */
    readonly token: CancellationToken;
    /**
     * Gets a value indicating whether cancellation has been requested.
     */
    readonly cancellationRequested: boolean;
    /**
     * Gets a value indicating whether the source can be canceled.
     */
    readonly canBeCanceled: boolean;
    /**
     * Cancels the source, returning a Promise that is settled when cancellation has completed.
     * Any registered callbacks are executed in a later turn. If any callback raises an exception,
     * the first such exception can be observed by awaiting the return value of this method.
     */
    cancel(): Promise<void>;
    /**
     * Closes the source, preventing the possibility of future cancellation.
     */
    close(): void;
    /**
     * Registers a callback to execute when cancellation has been requested. If cancellation has
     * already been requested, the callback is executed immediately.
     *
     * @param callback The callback to register.
     */
    register(callback: () => void): CancellationTokenRegistration;
    /**
     * Executes the provided callback in a later turn.
     *
     * @param callback The callback to execute.
     */
    private _executeCallback(callback);
    /**
     * Unlinks the source from any linked tokens.
     */
    private _unlink();
}
/**
 * Propagates notifications that operations should be canceled.
 */
export declare class CancellationToken {
    /**
     * A token which will never be canceled.
     */
    static readonly none: CancellationToken;
    /**
     * A token that is already canceled.
     */
    static readonly canceled: CancellationToken;
    private _source;
    /**
     * Creates a new instance of a CancellationToken.
     *
     * @param canceled An optional value indicating whether the token is canceled.
     */
    constructor(canceled?: boolean);
    /**
     * Gets a value indicating whether cancellation has been requested.
     */
    readonly cancellationRequested: boolean;
    /**
     * Gets a value indicating whether the underlying source can be canceled.
     */
    readonly canBeCanceled: boolean;
    /**
     * Throws a CancelError if cancellation has been requested.
     */
    throwIfCancellationRequested(): void;
    /**
     * Registers a callback to execute when cancellation is requested.
     *
     * @param callback The callback to register.
     */
    register(callback: () => void): CancellationTokenRegistration;
}
/**
 * An error thrown when an operation is canceled.
 */
export declare class CancelError extends Error {
    constructor(message?: string);
}
/**
 * An object used to unregister a callback registered to a CancellationToken.
 */
export interface CancellationTokenRegistration {
    /**
     * Unregisters the callback
     */
    unregister(): void;
}
