{
  "_args": [
    [
      {
        "raw": "prex@^0.2.0",
        "scope": null,
        "escapedName": "prex",
        "name": "prex",
        "rawSpec": "^0.2.0",
        "spec": ">=0.2.0 <0.3.0",
        "type": "range"
      },
      "C:\\Users\\Domenic\\Dropbox\\GitHub\\jsdom-proxy-benchmark\\node_modules\\ecmarkup"
    ]
  ],
  "_from": "prex@>=0.2.0 <0.3.0",
  "_id": "prex@0.2.0",
  "_inCache": true,
  "_location": "/prex",
  "_nodeVersion": "6.0.0",
  "_npmOperationalInternal": {
    "host": "packages-12-west.internal.npmjs.com",
    "tmp": "tmp/prex-0.2.0.tgz_1468609694287_0.9192805320490152"
  },
  "_npmUser": {
    "name": "rbuckton",
    "email": "rbuckton@chronicles.org"
  },
  "_npmVersion": "3.4.0",
  "_phantomChildren": {},
  "_requested": {
    "raw": "prex@^0.2.0",
    "scope": null,
    "escapedName": "prex",
    "name": "prex",
    "rawSpec": "^0.2.0",
    "spec": ">=0.2.0 <0.3.0",
    "type": "range"
  },
  "_requiredBy": [
    "/ecmarkup",
    "/grammarkdown"
  ],
  "_resolved": "https://registry.npmjs.org/prex/-/prex-0.2.0.tgz",
  "_shasum": "b88c2fa4d32182b01c1a33775a32746d4e33a7c5",
  "_shrinkwrap": null,
  "_spec": "prex@^0.2.0",
  "_where": "C:\\Users\\Domenic\\Dropbox\\GitHub\\jsdom-proxy-benchmark\\node_modules\\ecmarkup",
  "author": {
    "name": "Ron Buckton",
    "email": "ron.buckton@microsoft.com",
    "url": "http://github.com/rbuckton"
  },
  "bugs": {
    "url": "http://github.com/rbuckton/prex/issues"
  },
  "dependencies": {},
  "description": "Async coordination primitives and extensions on top of ES6 Promises",
  "devDependencies": {
    "chai": "^3.5.0",
    "del": "^1.2.0",
    "gulp": "^3.8.11",
    "gulp-istanbul": "^0.10.3",
    "gulp-mocha": "^2.1.0",
    "gulp-sourcemaps": "^1.6.0",
    "gulp-typescript": "^2.10.0",
    "gulp-util": "^3.0.4",
    "merge2": "^0.3.6",
    "mocha": "^2.2.5",
    "source-map-support": "^0.2.10",
    "typescript": "^1.9.0-dev.20160205"
  },
  "directories": {},
  "dist": {
    "shasum": "b88c2fa4d32182b01c1a33775a32746d4e33a7c5",
    "tarball": "https://registry.npmjs.org/prex/-/prex-0.2.0.tgz"
  },
  "gitHead": "1ba3770c306aa147d83c5ef51c357c2b8a9954a4",
  "homepage": "https://github.com/rbuckton/prex#readme",
  "keywords": [
    "async",
    "promise",
    "promises",
    "future",
    "deferred",
    "promise-a",
    "promise-a-plus",
    "then",
    "await",
    "coordination",
    "semaphore",
    "cancellation",
    "cancellationtoken"
  ],
  "license": "Apache-2.0",
  "main": "out/lib/index.js",
  "maintainers": [
    {
      "name": "rbuckton",
      "email": "rbuckton@chronicles.org"
    }
  ],
  "name": "prex",
  "optionalDependencies": {},
  "readme": "<!--\r\nCopyright (c) Microsoft Corporation.  \r\nLicensed under the Apache License, Version 2.0.\r\n\r\nSee LICENSE file in the project root for details.\r\n-->\r\n\r\n# Promise Extensions for JavaScript (prex)\r\nAsynchronous coordination for JavaScript and TypeScript.\r\n\r\nThis library contains a number of coordination primitives to assist in asynchronous application development in JavaScript and TypeScript.\r\nThis includes useful additions for building complex asynchronous logic including:\r\n\r\n* Cancellation \\[[Sample](#cancellation), [API Reference](docs/cancellation.md)\\]\r\n* Coordination \\[[Sample](#coordination), [API Reference](docs/coordination.md)\\]\r\n* Scheduling \\[[Sample](#scheduling), [API Reference](docs/scheduling.md)\\]\r\n\r\n# Installing\r\n\r\nFor the latest version:\r\n\r\n```\r\nnpm install prex\r\n```\r\n\r\n# Documentation\r\n\r\n* [API Reference](docs/index.md)\r\n    * [Cancellation](docs/cancellation.md)\r\n        * [Class: CancellationTokenSource](docs/cancellation.md#class-cancellationtokensource)\r\n        * [Class: CancellationToken](docs/cancellation.md#class-cancellationtoken)\r\n        * [Class: CancelError](docs/cancellation.md#class-cancelerror)\r\n        * [Interface: CancellationTokenRegistration](docs/cancellation.md#interface-cancellationtokenregistration)\r\n    * [Coordination](docs/coordination.md)\r\n        * [Class: ManualResetEvent](docs/coordination.md#class-manualresetevent)\r\n        * [Class: AutoResetEvent](docs/coordination.md#class-autoresetevent)\r\n        * [Class: Semaphore](docs/coordination.md#class-semaphore)\r\n        * [Class: CountdownEvent](docs/coordination.md#class-countdownevent)\r\n        * [Class: Barrier](docs/coordination.md#class-barrier)\r\n        * [Class: ReaderWriterLock](docs/coordination.md#class-readerwriterlock)\r\n        * [Interface: LockHandle](docs/coordination.md#interface-lockhandle)\r\n        * [Interface: UpgradeableLockHandle](docs/coordination.md#interface-upgradeablelockhandle)\r\n        * [Class: Deferred](docs/coordination.md#class-deferred)\r\n    * [Scheduling](docs/scheduling.md)\r\n        * [Class: AsyncQueue](docs/scheduling.md#class-asyncqueue)\r\n        * [Class: AsyncStack](docs/scheduling.md#class-asyncstack)\r\n        * [Function: delay(msec, value?)](docs/scheduling.md#function-delaymsec-value)\r\n\r\n# Samples\r\n\r\n## Cancellation\r\n> API Reference: [Cancellation](docs/cancellation.md)\r\n\r\nThe [CancellationTokenSource](docs/cancellation.md#class-cancellationtokensource) and\r\n[CancellationToken](docs/cancellation.md#class-cancellationtoken) primitives allow you to\r\ncreate asynchronous operations that can be canceled externally. The following is an example\r\nof a function used to download a file asynchronously that can be canceled:\r\n\r\n```ts\r\nimport * as http from \"http\";\r\nimport * as fs from \"fs\";\r\nimport { CancellationTokenSource, CancellationToken } from \"prex\";\r\n\r\nfunction downloadFile(from: string, to: string, token = CancellationToken.none) {\r\n    return new Promise<void>((resolve, reject) => {\r\n        const request = http.get(from);\r\n\r\n        // abort the request if canceled.\r\n        const registration = token.register(() => {\r\n            request.abort();\r\n            reject(new Error(\"Operation canceled.\"));\r\n        });\r\n\r\n        request.on(\"error\", err => {\r\n            registration.unregister();\r\n            reject(err);\r\n        });\r\n\r\n        request.on(\"response\", (response: http.IncomingMessage) => {\r\n            response\r\n                .pipe(fs.createWriteStream(to))\r\n                .on(\"error\", err => {\r\n                    registration.unregister();\r\n                    reject(err);\r\n                })\r\n                .on(\"end\", () => {\r\n                    registration.unregister();\r\n                    resolve();\r\n                });\r\n        });\r\n    });\r\n}\r\n\r\nasync function main() {\r\n    const source = new CancellationTokenSource();\r\n\r\n    // cancel the source if the file takes more than one second to download\r\n    setTimeout(1000, () => source.cancel());\r\n\r\n    await downloadFile(\"http://tempuri.org/some/file\", \"file\", source.token);\r\n}\r\n```\r\n\r\n## Coordination\r\n> API Reference: [Coordination](docs/coordination.md)\r\n\r\nA [Semaphore](docs/coordination.md#class-semaphore) can be used to protect access to a critical\r\nsection of your code when you must limit access across multiple async operations. The following\r\nis an example of two functions which both need exclusive access to a single resource but could\r\npossibly be preempted when suspended while awaiting an asynchronous operation:\r\n\r\n```ts\r\nimport { Semaphore } from \"prex\";\r\n\r\nconst criticalResource = new Semaphore(1);\r\n\r\nasync function updateCriticalLocalResource() {\r\n    // Acquire a lock on the critical resource\r\n    await criticalResource.wait();\r\n\r\n    // Make local changes...\r\n\r\n    // await a network resources\r\n    await postUpdateToNetworkResource(changes);\r\n\r\n    // release the lock\r\n    criticalResource.release();\r\n}\r\n\r\nasync function deleteCriticalLocalResource() {\r\n    // Acquire a lock on the critical resource\r\n    await criticalResource.wait();\r\n\r\n    // Make local changes...\r\n\r\n    // await a network resources\r\n    await postUpdateToNetworkResource(changes);\r\n\r\n    // release the lock\r\n    criticalResource.release();\r\n}\r\n\r\ndeclare function postUpdateToNetworkResource(changes): Promise<void>;\r\n```\r\n\r\nA [Barrier](docs/coordination.md#class-barrier) can be used to coordinate complex async operations:\r\n\r\n```ts\r\nimport { Barrier } from \"prex\";\r\n\r\nconst barrier = new Barrier(/*participantCount*/ 3);\r\n\r\nasync function processNpcAI() {\r\n    while (true) {\r\n        // process AI activities...\r\n        await barrier.signalAndWait();\r\n    }\r\n}\r\n\r\nasync function processGameRules() {\r\n    while (true) {\r\n        // process game rules\r\n        await barrier.signalAndWait();\r\n    }\r\n}\r\n\r\nasync function processGameInput() {\r\n    while (true) {\r\n        // process user input\r\n        await barrier.signalAndWait();\r\n    }\r\n}\r\n\r\n```\r\n\r\n## Scheduling\r\n> API Reference: [Scheduling](docs/scheduling.md)\r\n\r\nAn [AsyncQueue](docs/scheduling.md#class-asyncqueue) is a useful primitive for scheduling\r\nasynchronous work:\r\n\r\n```ts\r\nimport { AsyncQueue } from \"prex\";\r\n\r\nconst workItems = new AsyncQueue();\r\n\r\nfunction queueUserWorkItem(action: () => void) {\r\n    workItems.put(action);\r\n}\r\n\r\nasync function processWorkItems() {\r\n    while (true) {\r\n        const action = await workItems.get();\r\n        try {\r\n            action();\r\n        }\r\n        catch (e) {\r\n            console.error(e);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n# License\r\nCopyright (c) Microsoft Corporation.  \r\nLicensed under the Apache License, Version 2.0.\r\n\r\nSee [LICENSE](LICENSE) file in the project root for details.\r\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/rbuckton/prex.git"
  },
  "scripts": {
    "build": "gulp build",
    "test": "gulp test"
  },
  "typings": "out/lib/index.d.ts",
  "version": "0.2.0"
}
